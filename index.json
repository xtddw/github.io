[{"content":" Python Cookbook Python Web 入坑指南 《Python in Practice》 Python面试题 《writing idiomatic python ebook》 《Python 3 Patterns, Recipes and Idioms》 《30个有关Python的小技巧》 《Hidden features of Python》 《Python程序员的10个常见错误》 《Python高级编程slide》 《Effective Python》 《编写高质量代码：改善Python程序的91个建议》 《Code Like a Pythonista: Idiomatic Python》 《The Little Book of Python Anti-Patterns》  None 空类型是对象 != 空字符串、空列表、0、False(值和类型都不相同)\n判空：\n1 2 3 4  if a:\rpass\rif not a:\rpass\r  对象存在不一定为真！\n1 2 3 4 5  class obj():\rdef __bool__(self):\rpass\rdef __len__(self):\rpass\r  常量全大写 ACCOUNT\nnew 和 init 的区别\n new 是一个静态方法，init 是一个实例方法 new 方法会返回一个创建的实例，而 init 什么都不返回 只有 new 返回一个 cls 实例时，后面的 init 才会被调用 当创建一个新实例时调用 new，初始化实例时用 init  Write Idiom Python 1 2 3  # 链式比较  if 1 \u0026lt; a \u0026lt; b:\rpass\r  1 2 3 4  #交换变量\r x = 10\ry = 5\rx, y = y, x\r  1 2  # 三目运算\r c = a if a ) b else b\r  1 2  # 拼接字符列表时，用join方法去实现\r \u0026#34;.\u0026#34;.join(string_list)\r  1 2  # 格式化字符时多使用format函数\r str = \u0026#34;myname: {} myage:{}\u0026#34;.format(name,age)\r  1 2 3  # 迭代式\r odd_list = [e for e in mylist if e % 2 == 1]\r{user[\u0026#39;name\u0026#39;]:user[\u0026#39;email\u0026#39;] for user in user_list if \u0026#39;email\u0026#39; in user}\r  1 2 3 4 5  # 条件判断时，避免直接和True, False, None进行比较(==)\r if var:\rpass\rif somethin is None:\rpass\r  1 2 3  # 使用enumerate代替for循环中的index变量访问\r for index, element in enumerate(my_container):\rprint \u0026#39;%d%s\u0026#39; % (index, element)\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # 避免使用可变(mutable)变量作为函数参数的默认初始化值\r # bad\r def function(l = []):\rl.append(1)\rreturn l\rprint function()\rprint function()\rprint function()\r# print\r [1]\r[1, 1]\r[1, 1, 1]\r# good 使用None作为可变对象占位符\r def function(l=None):\rif l is None:\rl = []\rl.append(1)\rreturn l\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # 用dict对象完成switch...case...的功能\r # bad\r def apply_operation(left_operand, right_operand, operator):\rif operator == \u0026#39;+\u0026#39;:\rreturn left_operand + right_operand\relif operator == \u0026#39;-\u0026#39;:\rreturn left_operand - right_operand\relif operator == \u0026#39;*\u0026#39;:\rreturn left_operand * right_operand\relif operator == \u0026#39;/\u0026#39;:\rreturn left_operand / right_operand\r# good\r def apply_operation(left_operand, right_operand, operator):\rimport operator as op\roperator_mapper = {\u0026#39;+\u0026#39;: op.add, \u0026#39;-\u0026#39;: op.sub, \u0026#39;*\u0026#39;: op.mul, \u0026#39;/\u0026#39;: op.truediv}\rreturn operator_mapper[operator](left_operand, right_operand)\r  1 2 3 4 5 6 7 8 9 10 11 12  # 访问tuple的数据项时，可以用namedtuple代替index的方式访问\r # bad\r rows = [(\u0026#39;lily\u0026#39;, 20, 2000), (\u0026#39;lucy\u0026#39;, 19, 2500)]\rfor row in rows:\rprint \u0026#39;{}`age is {}, salary is {} \u0026#39;.format(row[0], row[1], row[2])\r# good\r from collections import namedtuple\rEmployee = namedtuple(\u0026#39;Employee\u0026#39;, \u0026#39;name, age, salary\u0026#39;)\rfor row in rows:\remployee = Employee._make(row)\rprint \u0026#39;{}`age is {}, salary is {} \u0026#39;.format(employee.name, employee.age, employee.salary)\r  1 2 3  # 用isinstance来判断对象的类型\r if isinstance(some_object, (list, dict, str, tuple)):\rreturn len(some_object)\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  # 用with管理操作资源的上下文环境\r #在一个比较典型的场景里，如数据库操作，我们操作connection时一般要正常关闭连接，而不管是正常退出还是异常退出。如下：\r # bad\r class Connection(object):\rdef execute(self, sql):\rraise Exception(\u0026#39;ohoh, exception!\u0026#39;)\rdef close(self):\rprint \u0026#39;closed the Connection\u0026#39;\rtry:\rconn = Connection()\rconn.execute(\u0026#39;select * from t_users\u0026#39;)\rfinally:\rconn.close()\r# good\r class Connection(object):\rdef execute(self, sql):\rraise Exception(\u0026#39;ohoh, exception!\u0026#39;)\rdef close(self):\rprint \u0026#39;closed the Connection\u0026#39;\rdef __enter__(self):\rreturn self\rdef __exit__(self, errorType, errorValue, error):\rself.close()\rwith Connection() as conn:\rconn.execute(\u0026#39;select * from t_users\u0026#39;)\r  Python 服务端  Python语言基础考察点 Python算法与数据结构考察点 编程范式考察点 操作系统考察点 网络编程考察点 数据库考察点 Python Web 框架考察点 系统设计考察  一切皆对象 python 面向对象更彻底\n函数和类也是对象，属于一等公民\n 复制给一个变量  1 2 3 4  def ask(name=\u0026#39;zgx\u0026#39;):\rprint(name)\rmy_func = ask\rmy_func(\u0026#34;zgx\u0026#34;)\r  1 2 3 4 5  class Person:\rdef __init__(self):\rprint(\u0026#34;zgx\u0026#34;)\rmy_class = Person\rPerson()\r   添加到集合对象中  1 2 3 4  obj_list =[]\robj_list.append(Person)\rfor item_class in obj_list:\rprint(item_class())\r   作为参数传递给函数  1 2  def print_type(item):\rprint(type(item))\r   作为函数的返回值  1 2 3 4 5 6  def decorator_func():\rprint(\u0026#34;dec start\u0026#34;)\rretun ask\rmy_ask = decorator_func()\rmy_ask(\u0026#34;ENFI\u0026#34;)\r  type、object、class关系 type=\u0026gt;class=\u0026gt;obj\ntype类用来生产类，类来生成实例\nobject是最顶层基类，默认继承\ntype是一个类，也是对象,是自己的对象\npython中常见的内置类型   对象的三个特征:\n 身份(对象在内存中的地址，id()) 类型(int,double\u0026hellip;) 值    None 全局唯一\n  数值类型\n int float complex bool    迭代类型\n for    序列类型\n list bytes\\bytearray\\memoryview(二进制序列) range tuple str array    映射类型\n dict    集合\n set frozenset    上下文管理器\n with    其他\n 模块类型 class与实例obj 函数类型 方法类型 代码类型 object对象 type类型 elipsis类型（省略号） notimplemented类对象    魔法函数 双下划线开头结尾,一般不需要显式调用，python会自动调用。使用后会影响类本身的数据模型\n__getitem__ 实现可迭代\n深入理解类和对象 鸭子模型 实现多态，类实现同一个函数名，具体函数体不同\n1 2 3 4 5 6 7 8 9 10 11 12  class cat:\rdef say(self):\rprint(\u0026#34;i am a cat\u0026#34;)\rclass Dog:\rdef say(self):\rprint(\u0026#34;i am a dog\u0026#34;)\rclass Duck:\rdef say(self):\rprint(\u0026#34;i am a duck\u0026#34;)\ranimal = Cat #Dog #Duck\r animal().say()\r  ","description":"","id":0,"section":"code","tags":null,"title":"Base Python","uri":"https://xtddw.github.io/code/python/base/"},{"content":"Readed  小王子 圣埃克苏佩里 围城 钱钟书 活着 余华 1988我想和这个世界谈谈 韩寒 平凡的世界 路遥 明朝那些事儿 当年明月 万历十五年 黄仁宇 1Q84 村上春树 边城 沈从文 许三观卖血记 余华 文化苦旅 余秋雨 三国演义 罗贯中 红楼梦 曹雪芹 兄弟 余华 麦田的守望者 J.D 白鹿原 陈忠实 北京法源寺 李敖 呐喊 鲁迅 乌合之众 勒庞 阿Q正传 鲁迅 如何阅读一本书 艾德勒 乔布斯传 艾萨克森 长恨歌 王安忆 京华烟云 林语堂 飞鸟集 泰戈尔 三体 刘慈欣  Like Read  解忧杂货店 东野圭吾  ","description":"","id":1,"section":"life","tags":null,"title":"Book","uri":"https://xtddw.github.io/life/book/"},{"content":"redis docker pull redis\n 创建redis容器，启动redis-server  docker run -d --name myredis -p 6379:6379 -v /c:/Workspace/redis redis --appendonly yes\ndockers中开启磁盘共享\n​\t* -it 启动交互界面\n 启动redis cli\n docker exec -it py-redis redis-cli\n  python\npip install redis\n  test\nfrom redis import Redis\nr = Redis(host='127.0.0.1\u0026rsquo;, port=6379, db=0)\n  mysql docker pull mysql\nmkdir docker_v/mysql/conf\ntouch my.conf\ndocker run -p 3306:3306 --name mysql -v /opt/docker_v/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 -d mysql\n","description":"","id":2,"section":"note","tags":null,"title":"docker","uri":"https://xtddw.github.io/note/docker/"},{"content":"用Pythonic方式来思考 确认python版本  python2 python3 CPython Jython IronPython PyPy  1  python --version\r  1 2 3  import sys\rprint(sys.version)\rprint(sys.version_info)\r  遵循PEP8风格指南 python Enhancement Proposal #8\nPylint 源码静态分析工具\n空白  使用space表示缩进，不要使用tab 4个空格 每行字符数不应超过79 函数与类之间两个空行隔开 同一个类中个方法之间用一个空行隔开 使用下标来获取列表元素、调用函数或给关键字参数赋值的时候，不要在两旁添加空格 赋值=前后加空格  命名  函数、变量及属性小写，下划线连接 lowercase_underscore 受保护的实例属性，单下划线开头 _leading_underscore 私有的实例属性，双下划线开头 __double_leading_underscore 类与异常，首字符大写 CapitalizWord 模块级别的变量，应全部大写，下划线连接 ALL_CAPS 类中的实例方法（instance method),首个参数命名为self 类方法（class method),首个参数命名为cls  表达式和语句  采用内联形式的否定词。 if a is not b \u0026gt; if not a is b 不要通过检查长度的方法来判断list是否为[]或'\u0026lsquo;等空值。 if not somelist\u0026gt;if len(somelist)==0 不要编写单行的for、if 、while、except符合语句 import语句应该总是放在文件开头 引入模块时，总是使用绝对名称，而不应该根据当前模块的路径来使用相对名称。引入bar包中的foo模块时，应该完整地写出from bar import foo 》 import foo,或者采用明确写法 from . import foo  bytes|str|unicode区别 python3字符序列类型\n bytes （实例包含原始8个字节） str （实例包含Unicode字符）  Unicode=\u0026gt;二进制 encode 编码 UTF-8\n二进制=》Unicode decode 解码\n解码与编码操作放在界面最外围来做，程序核心部分使用Unicode字符类型，而且不要对字符编码做任何假设。\npython3中，内置open函数获取了文件句柄，默认采用UTF-8编码格式来操作文件。open函数添加了encoding新参数，默认值为'utf-8\u0026rsquo;,必须传入包含Unicode字符的str实例，而不接受包含二进制的bytes实例。\u0026lsquo;wb\u0026rsquo; \u0026lsquo;rb'来开启可以解决上述问题\n用辅助函数来取代复杂的表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  red = int(my_values.get(\u0026#39;red\u0026#39;,[\u0026#39;\u0026#39;])[0] or 0)\rred = my_values.get(\u0026#39;red\u0026#39;,[\u0026#39;\u0026#39;])\rred = int(red[0]) if red[0] else 0\rred = my_values.get(\u0026#39;red\u0026#39;,[\u0026#39;\u0026#39;])\rif red[0]:\rred = int(green[0])\relse:\rred = 0\r## 辅助函数封装\r def get_first_int(values,key,default=0):\rfound = values.get(key,[\u0026#39;\u0026#39;])\rif found[0]:\rfound = int(found[0])\relse:\rfound = default\rreturn found\rred = get_first_int(my_values,\u0026#39;red\u0026#39;)\r  了解切割序列的方法 somelist[start🔚stride]\n start 起始索引，涵盖 end 结束索引，不涵盖 stride 步进，不要同时使用，先范围切割，再步进切割，而且不要设定负值 start=0或者end=len(list),应该省略 切片操作不会计较start与end是否越界  列表推导式来取代map|filter 1 2 3 4 5 6  a = [1,2,3,4,5,6]\rsquares = [ x**2 for x in a]\rsquares = map(lambda x:x**2,a)\reven_squares = [x**2 for x in a if x%2 == 0]\ralt = map(lambda x:x**2,filter(lambda x:x%2 ==0，a))\r  1 2 3 4 5  chile_ranks={\u0026#39;ghost\u0026#39;:1,\u0026#39;habanero\u0026#39;:2,\u0026#39;cayenne\u0026#39;:3}\rrank_dict={rank:name for name,rank in chile_ranks.items()}\r#{ 1:\u0026#39;ghost\u0026#39;,2:\u0026#39;habanero\u0026#39;,3,\u0026#39;cayenne\u0026#39;}\r chile_len_set={len(name) for name in rank_dict.values()}\r## {8,5,7}\r   列表推导式支持多级循环，每一级循环也支持多项条件，超过两个表达式的列表推导不建议使用\n用生成器表达式来改写数据量较大的列表推导 1 2  value = [len(x) for x in open(\u0026#39;test.txt\u0026#39;)]\r## 文件较大时 会出问题，适合少量的输入值\r   生成器表达式generator expression对列表推导和生成器的一种泛化\n生成器表达式在运行的时候，并不会把整个输出序列都呈现出来，而是会估值为迭代器（iterator)。每次可以根据生成器表达式产生一项数据。\n把实现列表推导所用的写法放在（）中，就构成了生成器表达式。他会立即返回一个迭代器，而不会深入处理文件中的内容。\n1 2 3 4  it = (len(x) for x in open(\u0026#39;test.txt\u0026#39;))\r## \u0026lt;generator object ....\u0026gt;\r next(it)\r## 1000\r   尽量使用enumerate取代range enumerate可以把各种迭代器包装为生成器，每次产出一对输出值，前者表示循环下标，后者表示迭代器中渠道的下一个序列元素\n1 2 3 4 5  for i, flavor in enumerate(flavor_list):\rprint(\u0026#39;%d:%s\u0026#39; %(i+1,flavor))\r## 可以指定enumerate函数开始计数所用值\r for i, flavor in enumerate(flavor_list,1):\rprint(\u0026#39;%d:%s\u0026#39; %(i,flavor))\r  用zip函数同时遍历两个迭代器 1 2 3 4 5 6 7 8  names=[\u0026#39;James\u0026#39;,\u0026#39;Kobe\u0026#39;,\u0026#39;Zgx\u0026#39;]\rletters=[len(n) for n in names]\rlongest_name=None\rmax_letters =0\rfor name, count in zip(names,letters):\rif count\u0026gt;max_letters:\rlongest_name = name\rmax_letters = count\r  合理利用try/except/else/finally   finally\n若既要将异常向上传播，又要在异常发生时执行清理工作\n  1 2 3 4 5 6 7 8 9  handle = open(\u0026#39;test.txt\u0026#39;)\rtry: data = handle.read()\rfinally:\rhandle.close()\r## 注意open 方法必须放在try块外面，如果打开文件时发生异常，那么程序应该跳过finally块。\r ## 使用上下文更简便\r with open(\u0026#39;test.txt\u0026#39;) as f:\rdata = f.read()\r   else\ntry/except/else结果可以清晰描述出那些异常由自己的代码处理，那些异常会传播到上一级。如果try块没有发生异常，那么执行else;如果try块发生了异常，那么执行except块。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  def load_json_key(data,key):\rtry:\rresult_dict = json.loads(data) #may raise ValueError\r except ValueError as e:\rraise KeyError from e\relse:\rreturn result_dict[key] ## may raise KeyError\r 3. 混合使用\r```python def divide_json(path):\rhandle = open(path,\u0026#39;r+\u0026#39;) ## may raise IOError\r try:\rdata = handle.read() ## may raise UnicodeDecodeError\r op = json.loads(data) ## may raise ValueError\r value = (op[\u0026#39;numerator\u0026#39;]/op[\u0026#39;denominator\u0026#39;]) ## may raise ZeroDivisionError\r except ZeroDivisionError as e:\rreturn UNDEFINED\relse:\rop[\u0026#39;result\u0026#39;]= value\rresult = json.dumps(op)\rhandle.write(result) #may raise IOError\r return value\rfinally:\rhandle.close() ## Always runs\r   ","description":"","id":3,"section":"code","tags":null,"title":"effective python","uri":"https://xtddw.github.io/code/python/effective-python/"},{"content":"配置  用户名和邮件\n$ git config --global user.name \u0026quot;zhanggx\u0026quot;\n$ git config --global user.email enfizgx@163.com 设置别名  sudo git config \u0026ndash;system alias.st status sudo git config \u0026ndash;system alias.ci commit sudo git config \u0026ndash;system alias.co checkout sudo git config \u0026ndash;system alias.br branch   开启颜色提示  git config \u0026ndash;global color.ui true    教程 ","description":"","id":4,"section":"note","tags":null,"title":"git","uri":"https://xtddw.github.io/note/git/"},{"content":" FindHao v2ex Hosts修改翻墙  ","description":"","id":5,"section":"note","tags":null,"title":"link","uri":"https://xtddw.github.io/note/link/"},{"content":"电影  肖申克的救赎 霸王别姬 这个杀手不太冷 千与千寻 泰坦尼克号 阿甘正传 盗梦空间 海上钢琴师 三傻大闹宝莱坞 忠犬八公的故事 大话西游之大圣娶亲/仙履奇缘 大话西游之月光宝盒 龙猫 教父1/2/3 搏击俱乐部 无间道 天空之城 少年派的奇幻漂流 鬼子来了 活着 两杆大烟枪 哈尔的移动城堡 七宗罪 饮食男女 入殓师 素媛 黑客帝国 蝴蝶效应 拯救大兵瑞恩 幽灵公主 让子弹飞 阳光灿烂的日子 重庆森林 射雕英雄传之东成西就 上帝之城 禁闭岛 致命ID 一一 末代皇帝 摩登时代 风之谷 萤火虫之墓 幸福终点站 菊次郎的夏天 倩女幽魂 电锯惊魂 谍影重重 雨人 东邪西毒 杀人回忆 喜宴 喜剧之王 英雄本色 花样年华 冰川时代 唐伯虎点秋香 秒速五厘米 阿飞正传 爆裂鼓手 牯岭街少年杀人事件 魔女宅急便 新龙门客栈 国王的演讲 遗愿清单 疯狂的石头 天注定 颐和园 摔跤吧！爸爸 驴得水 剑雨 一个陌生女人的来信 太阳照常升起  电视剧  走向共和 天道 康熙王朝 绝命毒师 生活大爆炸 越狱 毛骗 大宅门 亮剑 外乡人 武林外传 潜伏 三国演义 白鹿原 士兵突击 茶馆 我爱我家  ","description":"","id":6,"section":"life","tags":null,"title":"Movie","uri":"https://xtddw.github.io/life/movie/"},{"content":" python data structures and algorithms\n  problem-solving-with-algorithms-and-data-structure-using-python  程序 = 算法 + 数据结构\n算法（Algorithm）：是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。\n数据结构（Data Structures）：是计算机存储和组织数据的一种方式，可以用来高效地处理数据。\n举个例子：二分查找就是一个非常经典的算法，而二分查找经常需要作用在一个有序数组上。这里二分就是一种折半的算法思想，\n而数组是我们最常用的一种数据结构，支持根据下标快速访问。很多算法需要特定的数据结构来实现，所以经常把它们放到一块讲。\n实际上，在真正的项目开发中，大部分时间都是 从数据库取数据 -\u0026gt; 数据操作和结构化 -\u0026gt; 返回给前端，在数据操作过程中需要合理地抽象，\n组织、处理数据，如果选用了错误的数据结构，就会造成代码运行低效。这也是我们需要学习算法和数据结构的原因。\n抽象数据类型和面向对象编程 内置常用算法和数据结构  常用内置数据类型：list, tuple, dict, set, frozenset, collections, heapq, bisect     数据结构/算法 语言内置 内置库     线性结构 list(列表)/tuple(元祖) array(数组，不常用)/collections.namedtuple   链式结构  collections.deque(双端队列)   字典结构 dict(字典) collections.Counter(计数器)/OrderedDict(有序字典)/defaultdict   集合结构 set(集合)/frozenset(不可变集合)    排序算法 sorted    二分算法  bisect模块   堆算法  heapq模块   缓存算法  functools.lru_cache(Least Recent Used, python3)    链表 队列 栈 算法分析 哈希表 字典 集合 递归 线性查找与二分查找 基本排序算法 高级排序算法  高级排序算法 分治法与归并排序 快速排序  树与二叉树 堆和堆排序 优先级队列 二叉查找树 图与图的遍历 ","description":"","id":7,"section":"code","tags":null,"title":"Python数据结构与算法","uri":"https://xtddw.github.io/code/python/aads/"},{"content":"set key value\nget key\nmset mget 一次设置读取多个值\nexists 判断key是否存在\ndel 删除key\ntype 检查value类型\nexpire 设置key的有效值 expire key 时长(s)\nex : set key value ex 时长(s)\nttl: 查看key剩余时间\n","description":"","id":8,"section":"note","tags":null,"title":"redis","uri":"https://xtddw.github.io/note/redis/"},{"content":"windows  Listary total commander AHK Everything 搜索  common  vim|neovim Emacs org-mode Potlayer WW 视频播放器 Foobar2000 音乐播放器 Ditto 剪贴版加强 hexo 博客 mkdocs 文档 Firefox/Chrome 浏览器（奔跑的奶牛）  书签同步 XMarks   鼠标手势 CLEAN crxMouse Gestures vim模式操作  Vimium github增强树结构 octotree 惠惠购物助手 自定义显示样式 stylish 网站 插件管理 Tampermonkey (油猴) 搜索脚本    ","description":"","id":9,"section":"note","tags":null,"title":"soft","uri":"https://xtddw.github.io/note/soft/"},{"content":"web前端开发工程师 职位职责：\n  参与Web前端项目架构及核心代码研发工作；\n  各产品web端功能的设计开发及实现；\n  JS与其他语言的混合型应用开发；\n  配合后端工程师完成产品前台页面的开发；\n  根据产品需求，从技术的角度进行评估，并给出建议，推动用户体验的优化。\n  解决各种浏览器设备和移动设备的兼容性问题；\n  负责完成领导交办其它各项工作；\n  学习新技术，提高开发能力；\n  岗位要求：\n 本科以上学历，学习能力强，适应能力好。 熟悉javascript，HTML，CSS等相关技术，熟悉页面架构及布局、熟悉浏览器的资源加载、渲染机制。 至少熟练掌握Angular，Vue，React框架其中一种，并有相关SPA项目经验，能够处理页面复杂数据交互； 熟练掌握常用开发工具和调试技巧，如Git，抓包工具，命令行等； 良好的编码习惯和团队合作精神，较强的沟通能力及较好的创新能力，诚实、细致、敬业； 3年以上Web前端开发经验者优先、有Electron使用经验者优先。  智能冶炼后端开发工程师 职位职责：\n  参与有色冶炼智能工厂项目设计与架构设计。\n  负责业务流程分析、详细设计、数据库设计、测试报告等相关技术材料编制工作；\n  负责系统模块的开发与单元测试。\n  负责完成领导交办其它各项工作；\n  学习新技术，提高开发能力；\n  岗位要求：\n 本科以上学历，学习能力强，适应能力好，关注新技术； 基础知识扎实，熟悉面向对象设计方法，熟悉常用数据结构、算法及设计模式； 熟练掌握C#或python语言; 熟悉Asp dotnet Core技术框架或python web开发框架（flask熟悉者优先）; 熟悉MySQL、 SQL Server等数据库CURD操作; 良好的编码习惯和团队合作精神，较强的沟通能力及较好的创新能力，诚实、细致、敬业; 熟练掌握常用开发工具和调试技巧，如Git，基本linux操作等； 对复杂的服务端系统有构架、优化经验者优先; 具有冶金相关专业学习背景者优先  ","description":"","id":10,"section":"work","tags":null,"title":"人才招聘","uri":"https://xtddw.github.io/work/doc/"},{"content":"风之谷 1984年：风之谷（风の谷のナウシカ)\n天空之城 1986年：天空之城(天空の城ラピュタ)\n龙猫 1988年：龙猫(となりのトトロ)\n魔女宅急便 1989年：魔女宅急便(魔女の宅急便)\n红猪 1992年：红猪(红の豚)\n幽灵公主 1997年：幽灵公主(もののけ姫)\n千与千寻 2001年：千与千寻(千と千寻の神隠し)\n哈尔的移动城堡 2004年：哈尔的移动城堡（ハウルの动く城)\n悬崖上的金鱼姬 2008年：悬崖上的金鱼姬（崖の上のポニョ)\n起风了 2013年：起风了（风立ちぬ)\n","description":"","id":11,"section":"life","tags":null,"title":"宫崎骏","uri":"https://xtddw.github.io/life/gqj/"},{"content":"似水流年 2003年9月\n 绽放 似水流年 远 一辈子的十分钟 今生今世 遥不可及 什刹海 八月照相馆 温暖 传奇 紫罗兰  为你而来 2005年1月\n 为你而来 不知不觉 在海上 明天还会在路上 父亲 向往 恋人 云上的日子 纵身一跳 你像从前一样  什刹海 2006年10月\n 不知不觉 什刹海 一辈子的十分钟 八月照相馆 远 似水流年 为你而来 父亲 绽放 向往  想念你 2007年4月\n  抚仙湖\n  风吹麦浪\n  童年\n  超越\n  松花江\n  天狐\n  异乡人\n   词：李健\n曲：李健\n披星戴月地奔波\n只为一扇窗\n当你迷失在路上\n能够看见那灯光\n不知不觉把他乡\n当做了故乡\n只是偶尔难过时\n不经意遥望远方\n曾经的乡音\n悄悄地隐藏\n说不出的诺言\n一直放心上\n有许多时候\n眼泪就要流\n那扇窗是让我坚强的理由\n小小的门口\n还有她的温柔\n给我温暖陪伴我左右\n   想念你\n  小鸟睡在我身旁\n  异乡人（伴奏）\n  寂寞星空·见歌 2008年10月\n 遥远的天空底下 露天电影院 矜持 陀螺 溺爱 大海啊,故乡 梦一场 窗台 绒花 再别康桥  音乐傲骨 2009年12月\n 璀璨   作曲 : 李健\n作词 : 李健\n没有一朵花 留住它的季节\n像我一样 不能在你身边 到永远\n总有一阵风 要带走些什么\n像你一样 离去时总不说 再见\n生命如此无常\n我总是一样 不停地追寻我终究要 失去的\n像一阵风在原野流浪\n生命就是这样\n我却是无常 永远不知道下一刻 欢乐或悲伤\n像河水漫无目的流淌\n多绚烂的花 多美妙的季节\n说我爱你 请你一定相信 这一刻\n总有一阵风 要带走些什么\n像你一样 离去时总不说 再见\n生命如此无常\n我总是一样 不停地追寻我终究要 失去的\n像一阵风在原野流浪\n生命就是这样\n我却是无常 永远不知道下一刻 欢乐或悲伤\n像河水漫无目的流淌\n多绚烂的花 多美妙的季节\n我说爱你 请你一定相信 这一切\n   一往情深的恋人\n  圣洁之光\n  完美坚持\n  在每个想你的夜里\n  故乡山川\n   作曲 : 李健\n作词 : 李健\n当微风送花草清香\n正是我想你的季节\n远方的家是否无恙\n江水日夜流淌\n当风筝已漫天飞旋\n曾是你望眼欲穿\n往日时光\n匆匆流水\n带你奔向何方\n我心中的世界竟是如此遥远\n不知不觉中已离家千万里\n此刻灯火辉煌多想与你分享\n却再也不能回到你身边\n脚下虽有万水千山\n却远不过对你的思念\n看过多少\n月落日出\n没有相同的一天\n每当雪花绽放\n心也跟随飞舞\n曾经的候鸟\n如今身在何处\n在那遥远地方\n灯火依然昏黄\n却无数次\n照亮我的梦乡\n我心中的世界竟是如此遥远\n不知不觉中已离家千万里\n在那遥远地方灯火依然昏黄\n却无数次照亮我的梦乡\n  Lily 爱的四季 转眼瞬间 好望角 我的朋友 传奇 (2010版) *再版Bonus Track  传奇 2010年7月\n 传奇 当有天老去 *新歌 似水流年 绽放 我愿人长久 *新歌 远 为你而来 云上的日子 八月照相馆 恋人 什刹海 向往 父亲 一辈子的十分钟  依然 2011年12月\n 心升明月 Color Me Love 我始终在这里 回到从前 舍得 珍爱深深 依然在路上 贝加尔湖畔 眷恋 凌晨两点 谢谢你  拾光 2013年9月\n  向往\n  抚仙湖\n  为你而来\n  异乡人\n  风吹麦浪\n  远\n  你像从前一样\n  绽放\n  八月照相馆\n  恋人\n  丽江\n  当有天老去\n  一往情深的恋人\n  今生今世遥不可及\n  父亲\n  传奇 (2013重唱版)\n  李健 2015年8月\n  深海之寻\n  美若黎明\n  日落之前\n  沧海轻舟\n  雨后初晴\n  众妙\n  迷雾\n  风吹黄昏\n  消失的月光\n  假如爱有天意\n   词：李健\n曲：Yoo Young Seok\n当天边那颗星出现\n你可知我又开始想念\n有多少爱恋只能遥遥相望\n就像月光洒向海面\n年少的我们曾以为\n相爱的人就能到永远\n当我们相信情到深处在一起\n听不见风中的叹息\n谁知道爱是什么\n短暂的相遇却念念不忘\n用尽一生的时间\n竟学不会遗忘\n如今我们已天各一方\n生活得像周围人一样\n眼前人给我最信任的依赖\n但愿你被温柔对待\n多少恍惚的时候\n仿佛看见你在人海川流\n隐约中你已浮现\n一转眼又不见\n短暂的相遇却念念不忘\n多少恍惚的时候\n仿佛看见你在人海川流\n隐约中你已浮现\n一转眼又不见\n当天边那颗星出现\n你可知我又开始想念\n有多少爱恋今生无处安放\n冥冥中什么已改变\n月光如春风拂面\n ","description":"","id":12,"section":"life","tags":null,"title":"李健","uri":"https://xtddw.github.io/life/lijian/"},{"content":"饮酒-陶渊明  结庐在人境，而无车马喧\n问君何能尔，心远地自偏\n采菊东篱下，悠然见南山\n山气日夕佳，飞鸟相与还\n此中有真意，欲辨已忘言\n ","description":"","id":13,"section":"post","tags":null,"title":"诗词","uri":"https://xtddw.github.io/post/01_%E8%AF%97%E8%AF%8D/"},{"content":"江铜贵溪冶炼厂 重庆首届智博会 Smart China Export\n","description":"","id":14,"section":"work","tags":null,"title":"调研考察","uri":"https://xtddw.github.io/work/log/"},{"content":"安装工具  Nodejs npm Angular CLI   npm install -g @angular/cli\n 项目建立 ng new blog-client\ncd my-app\nng serve –open (aliasng serve -o)\n 常用命令  --dry-run (alias: -d) : Run through without making any changes. --style less : The file extension to be used for style files.    NG-ZORRO ng add ng-zorro-antd\n","description":"","id":15,"section":"code","tags":null,"title":"01_项目创建","uri":"https://xtddw.github.io/code/angular/angular_01_%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"content":"项目创建  ASP .NET Core Web Application 设置为Blog.Api 选择Empty+No Authentication 添加.NET Core类库，Blog.Core + Blog.Infrastructure  Infrastructure 依赖 Core Api 依赖 Infrastructure + Core    Program + Startup Program进行基础设施的配置，很少发生变化\n HTTP Server 集成 IIS 配置信息来源  Startup 配置自定义行为，可能经常发生变化\n 组件 服务 功能 中间件管道  Startup.cs\n  ConfigureServices 所有程序级的依赖项都可以在这里注册到默认的IoC容器里, 把它们添加到IServiceCollection即可\n  Configure 配置应该遵循Add/Use的风格样式, 首先定义需要什么, 然后定义如何使用它.是真正负责配置HTTP请求管道的方法, 并且运行时也需要它\n  基础配置 运行时环境 ASPNETCORE_ENVIRONMENT\n ASP.NET Core还允许我们按约定为指定环境建立单独的启动配置. 启动类可以通过这个函数定义UseStartup(startupAssemblyName: xxx); 运行时会在这个指定的组件查找叫做Startup, Startup[环境名]的类, 其中[环境名]就是ASPNETCORE_ENVIRONMENT这个环境变量的值. 如果能找到指定环境的类, 那么它将覆盖默认的启动类.\n  例如:环境变量值如果是Development的话, 那么运行时就会尝试寻找Startup和StartupDevelopment类, 该约定在启动类里面的方法名上也有效, 环境特定的启动类里的两个方法分别是 Configure[环境名]和Configure[环境名]Services.\n  ASPNETCORE_ENVIRONMENT环境变量 Production Development Staging 没有设置则使用Production\n 1 2 3 4 5  public static IWebHostBuilder CreateWebHostBuilder(string[] args) =\u0026gt; WebHost.CreateDefaultBuilder(args) //.UseStartup\u0026lt;Startup\u0026gt;();  .UseStartup(typeof(StartupDevelopment).GetTypeInfo().Assembly.FullName);   HTTPS\n 微软建议所有应用调用HTTPS重定向中间件，来把所有的HTTP请求重定向为HTTPS Startup：  ConfigureServices方法注册，并配置端口及状态码 Configure方法使用该中间件： app.UseHttpsRedirection()    1 2 3 4 5  services.AddHttpsRedirection(options =\u0026gt; { options.RedirectStatusCode = StatusCodes.Status307TemporaryRedirect; options.HttpsPort = 5001; });   HSTS （HTTP Strict Transport Sercurity Protocol）\n 微软建议在生产环境(production)下启用HSTS Startup：\n* ConfigureServices方法注册并配置 HSTS * Configure方法使用该中间件： app.UseHsts()  1 2 3 4 5 6 7 8 9  //HSTS 只配置在生产环境 services.AddHsts(options =\u0026gt; { options.Preload = true; options.IncludeSubDomains = true; options.MaxAge = TimeSpan.FromDays(60); options.ExcludedHosts.Add(\u0026#34;example.com\u0026#34;); options.ExcludedHosts.Add(\u0026#34;www.example.com\u0026#34;); });   launchSettings.json\n 开发时只保留console,其余删除  1 2 3 4 5 6 7 8 9 10 11 12 13  { \u0026#34;profiles\u0026#34;: { \u0026#34;Blog.Api\u0026#34;: { \u0026#34;commandName\u0026#34;: \u0026#34;Project\u0026#34;, \u0026#34;launchBrowser\u0026#34;: true, \u0026#34;launchUrl\u0026#34;: \u0026#34;http://localhost:5000/api/posts\u0026#34;, \u0026#34;applicationUrl\u0026#34;: \u0026#34;https://localhost:5001;http://localhost:5000\u0026#34;, \u0026#34;environmentVariables\u0026#34;: { \u0026#34;ASPNETCORE_ENVIRONMENT\u0026#34;: \u0026#34;Development\u0026#34; } } } }   ","description":"","id":16,"section":"code","tags":null,"title":"01_项目创建及基础配置","uri":"https://xtddw.github.io/code/dotnetcore/01%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"},{"content":"建立和注册Context  安装包 \u0026raquo;\u0026gt; Infrastructure项目   Microsoft.EntityFrameworkCore.Design Microsoft.EntityFrameworkCore.[Sqlite][SqlServer][MySql]\ndotnet add package Microsoft.EntityFrameworkCore.SqlServer\nInstall-Package Microsoft.EntityFrameworkCore.SqlServer  建立Context   Entities \u0026raquo;\u0026gt; Core项目  1 2 3 4 5 6 7 8  public class Post : Entity { // public int Id { get; set; }  public string Title { get; set; } public string Body { get; set; } public string Author { get; set; } public DateTime LastModified { get; set; } }    Context:DbContext \u0026raquo;\u0026gt;Infrastructure项目  1 2 3 4 5 6 7  public class ApplicationContext:DbContext { public ApplicationContext(DbContextOptions\u0026lt;ApplicationContext\u0026gt; options):base(options) { } public DbSet\u0026lt;Post\u0026gt; Posts { get; set; } }   Startup里注册Context  1 2 3 4 5 6 7  //注册Dbcontxt  services.AddDbContext\u0026lt;ApplicationContext\u0026gt;(options =\u0026gt; { //var contectionString = \u0026#34;Data Source = localhost; Database = Blog.db; User = sa; Password = password\u0026#34;;  var contectionString = \u0026#34;Data Source = .;Database = Blog.db;Integrated Security=True\u0026#34;; options.UseSqlServer(contectionString); });   数据库迁移   快速调出package manager console Alt + T N O add-migration [Name] update-database\n  添加种子数据   Seed.cs  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  public class Seed { public static async Task SeedAsync(ApplicationContext applicationContext, ILoggerFactory loggerFactory, int retry = 0) { int retryForAvailability = retry; try { // TODO: Only run this if using a real database  // myContext.Database.Migrate();  if (!applicationContext.Posts.Any()) { applicationContext.Posts.AddRange( new List\u0026lt;Post\u0026gt;{ new Post{ Title = \u0026#34;Post Title 1\u0026#34;, Body = \u0026#34;Post Body 1\u0026#34;, Author = \u0026#34;Dave\u0026#34;, LastModified = DateTime.Now }, new Post{ Title = \u0026#34;Post Title 2\u0026#34;, Body = \u0026#34;Post Body 2\u0026#34;, Author = \u0026#34;Dave\u0026#34;, LastModified = DateTime.Now }, new Post{ Title = \u0026#34;Post Title 3\u0026#34;, Body = \u0026#34;Post Body 3\u0026#34;, Author = \u0026#34;Dave\u0026#34;, LastModified = DateTime.Now }, new Post{ Title = \u0026#34;Post Title 4\u0026#34;, Body = \u0026#34;Post Body 4\u0026#34;, Author = \u0026#34;Dave\u0026#34;, LastModified = DateTime.Now }, new Post{ Title = \u0026#34;Post Title 5\u0026#34;, Body = \u0026#34;Post Body 5\u0026#34;, Author = \u0026#34;Dave\u0026#34;, LastModified = DateTime.Now }, new Post{ Title = \u0026#34;Post Title 6\u0026#34;, Body = \u0026#34;Post Body 6\u0026#34;, Author = \u0026#34;Dave\u0026#34;, LastModified = DateTime.Now }, new Post{ Title = \u0026#34;Post Title 7\u0026#34;, Body = \u0026#34;Post Body 7\u0026#34;, Author = \u0026#34;Dave\u0026#34;, LastModified = DateTime.Now }, new Post{ Title = \u0026#34;Post Title 8\u0026#34;, Body = \u0026#34;Post Body 8\u0026#34;, Author = \u0026#34;Dave\u0026#34;, LastModified = DateTime.Now } } ); await applicationContext.SaveChangesAsync(); } } catch (Exception ex) { if (retryForAvailability \u0026lt; 10) { retryForAvailability++; var logger = loggerFactory.CreateLogger\u0026lt;Seed\u0026gt;(); logger.LogError(ex.Message); await SeedAsync(applicationContext, loggerFactory, retryForAvailability); } } } }    Program中调用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public static void Main(string[] args) { var host = CreateWebHostBuilder(args).Build(); using (var scope = host.Services.CreateScope()) { var services = scope.ServiceProvider; var loggerFactory = services.GetRequiredService\u0026lt;ILoggerFactory\u0026gt;(); try { var applicationContext = services.GetRequiredService\u0026lt;ApplicationContext\u0026gt;(); //调用方法创建种子数据  Seed.SeedAsync(applicationContext, loggerFactory).Wait(); } catch (Exception e) { var logger = loggerFactory.CreateLogger\u0026lt;Program\u0026gt;(); logger.LogError(e, \u0026#34;Error occured seeding the Database.\u0026#34;); } } host.Run(); }    添加PostController  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  [Route(\u0026#34;api/posts\u0026#34;)] public class PostController : Controller { private readonly ApplicationContext _applicationContext; public PostController(ApplicationContext applicationContext) { _applicationContext = applicationContext; } [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get() { var posts = await _applicationContext.Posts.ToListAsync(); return Ok(posts); } }    成功\n  Repository 仓储服务 与持久化技术无关(使用其他Drapper等替代EF Core)、易于测试、代码重用\nIRepository接口：依赖注入、松耦合、DIP原则、易于测试\n 注入的是接口，而不是具体的类。如果注入Repository这个类，Controller就依赖了Repository，这样就是高级别模块依赖了低级别模块，违反了DIP原则! 应该都依赖于抽象IRepository接口。   IRepository \u0026raquo;\u0026gt; Core.Interface  1 2 3 4  public interface IPostRepository { Task\u0026lt;IEnumerable\u0026lt;Post\u0026gt;\u0026gt; GetAllPostsAsync(); }   Repository \u0026raquo;\u0026gt; Infrastructure.Repositories  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class PostRepository : IPostRepository { //注入DbContext  private readonly ApplicationContext _applicationContext; public PostRepository(ApplicationContext applicationContext) { _applicationContext = applicationContext; } public async Task\u0026lt;IEnumerable\u0026lt;Post\u0026gt;\u0026gt; GetAllPostsAsync() { return await _applicationContext.Posts.ToListAsync(); } }   Startup中注册服务  1 2  //注册仓储服务  services.AddScoped\u0026lt;IPostRepository, PostRepository\u0026gt;();    服务注册生命周期  Transient: 每次其它的类请求（不是指HTTP Request）都会创建一个新的实例，它比较适合轻量级的无状态的（Stateless）的service. Scope: 每次HTTP请求会创建一个实例。 Singleton: 在第一次请求的时候就会创建一个实例，以后也只有这一个实例; 或者在ConfigureServices这段代码运行的时候创建唯一一个实例。    修改Controller,注入Repository  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  [Route(\u0026#34;api/posts\u0026#34;)] public class PostController : Controller { private readonly IPostRepository _postRepository; public PostController(IPostRepository postRepository) { _postRepository = postRepository; } [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get() { var posts = await _postRepository.GetAllPostsAsync(); return Ok(posts); } }   Unit of Work 仓储服务  IUntiOfWork \u0026raquo;\u0026gt; Core.Interface  1 2 3 4  public interface IUnitOfWork { Task\u0026lt;bool\u0026gt; SaveAsync(); }   UnitOfWork \u0026raquo;\u0026gt; Infrastructure.Database  1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class UnitOfWork : IUnitOfWork { private readonly ApplicationContext _applicationContext; public UnitOfWork(ApplicationContext applicationContext) { _applicationContext = applicationContext; } public async Task\u0026lt;bool\u0026gt; SaveAsync() { return await _applicationContext.SaveChangesAsync() \u0026gt; 0; } }   Startup中注册服务  1 2  //注册仓储服务  services.AddScoped\u0026lt;IUnitOfWork , UnitOfWork \u0026gt;();   Repository添加AddPost方法  1 2 3 4  public void AddPost(Post post) { _applicationContext.Posts.Add(post); }   修改controller, 注入IUnitOfWork, Post()方法中调用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  [Route(\u0026#34;api/posts\u0026#34;)] public class PostController : Controller { private readonly IPostRepository _postRepository; private readonly IUnitOfWork _unitOfWork; public PostController( IPostRepository postRepository, IUnitOfWork unitOfWork) { _postRepository = postRepository; _unitOfWork = unitOfWork; } [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get() { var posts = await _postRepository.GetAllPostsAsync(); return Ok(posts); } [HttpPost] public async Task\u0026lt;IActionResult\u0026gt; Post() { var newPost = new Post { Title = \u0026#34;ENFI\u0026#34;, Author = \u0026#34;ZGX\u0026#34;, Body = \u0026#34;adskfasdjfladsjfa;ldsfads\u0026#34;, LastModified = DateTime.Now }; _postRepository.AddPost(newPost); await _unitOfWork.SaveAsync(); return Ok(); } }   Entity约束  PostConfiguration.cs \u0026raquo;\u0026gt; Infrastructure.EntityConfiguration  1 2 3 4 5 6 7 8 9  public class PostConfiguration : IEntityTypeConfiguration\u0026lt;Post\u0026gt; { public void Configure(EntityTypeBuilder\u0026lt;Post\u0026gt; builder) { builder.Property(x =\u0026gt; x.Author).IsRequired().HasMaxLength(50); builder.Property(x =\u0026gt; x.Title).IsRequired().HasMaxLength(100); builder.Property(x =\u0026gt; x.Body).IsRequired().HasColumnType(\u0026#34;nvarchar(max)\u0026#34;); } }   DbContext中重写OnModel  1 2 3 4 5  protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); modelBuilder.ApplyConfiguration(new PostConfiguration()); }   ","description":"","id":17,"section":"code","tags":null,"title":"02_集成EFCore","uri":"https://xtddw.github.io/code/dotnetcore/02%E9%9B%86%E6%88%90efcore/"},{"content":"Log  默认自带log \u0026raquo;\u0026gt;Program  1  WebHost.CreateDefaultBuilder()中做了默认配置   2. Log API\nASP .NET Core 提供了一套Log API, 它可以各种各样的Log提供商配合使用. http://www.cnblogs.com/cgzl/p/9019314.html\n内置6个Log提供商:\n Console Debug EventSource EventLog TraceSource Azure App Service\n第三方提供商： Nlog Serilog  ILogger接口  创建ILogger的时候指明分类，分类名约定是调用类的全名(string) PostController例如：\n依赖注入ILogger\u0026lt;TCategoryName\u0026gt;\n 在ILoggerFactory 上调用CreateLogger方法时可以指定分类的名称.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  [Route(\u0026#34;api/posts\u0026#34;)] public class PostController : Controller { private readonly IPostRepository _postRepository; private readonly IUnitOfWork _unitOfWork; private readonly ILogger _logger; public PostController( IPostRepository postRepository, IUnitOfWork unitOfWork, ILoggerFactory loggerFactory) { _postRepository = postRepository; _unitOfWork = unitOfWork; _logger = loggerFactory.CreateLogger(\u0026#34;Blog.Api.Controllers.PostController\u0026#34;); } [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get() { var posts = await _postRepository.GetAllPostsAsync(); _logger.LogError(\u0026#34;Get All Posts ......\u0026#34;); return Ok(posts); }   ILogger其他  级别  LogTrace(), 0，记录追踪信息 LogDebug(), 1，记录调试信息 LogInformation(), 2，记录信息性的事情 LogWarning(), 3，记录警告信息 LogError(), 4，记录异常 LogCritical(), 5，用来记录严重的事情   Event ID 信息模板 异常 过滤 作用范围\n……  添加Serilog  安装包\nInstall-Package Serilog\nInstall-Package Serilog.AspNetCore\nSinks日志输出媒介(控制台、文件、sqlserver等）\nInstall-Package Serilog.Sinks.Console\nInstall-Package Serilog.Sinks.File\n… Main()中配置  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  public static void Main(string[] args) { //配置Serilog  Log.Logger = new LoggerConfiguration() //最低输出级别为Debug  .MinimumLevel.Debug() //以Microsoft开头的特殊,调整最小级别为Information  .MinimumLevel.Override(\u0026#34;Microsoft\u0026#34;, LogEventLevel.Information) .Enrich.FromLogContext() .WriteTo.Console() .WriteTo.File(Path.Combine(\u0026#34;logs\u0026#34;, @\u0026#34;log.txt\u0026#34;), rollingInterval: RollingInterval.Day) .CreateLogger(); var host = CreateWebHostBuilder(args).Build(); //种子文件  using (var scope = host.Services.CreateScope()) { var services = scope.ServiceProvider; var loggerFactory = services.GetRequiredService\u0026lt;ILoggerFactory\u0026gt;(); try { var applicationContext = services.GetRequiredService\u0026lt;ApplicationContext\u0026gt;(); //调用方法创建种子数据  Seed.SeedAsync(applicationContext, loggerFactory).Wait(); } catch (Exception e) { var logger = loggerFactory.CreateLogger\u0026lt;Program\u0026gt;(); logger.LogError(e, \u0026#34;Error occured seeding the Database.\u0026#34;); } } host.Run(); } public static IWebHostBuilder CreateWebHostBuilder(string[] args) =\u0026gt; WebHost.CreateDefaultBuilder(args) //.UseStartup\u0026lt;Startup\u0026gt;();  .UseStartup(typeof(StartupDevelopment).GetTypeInfo().Assembly.FullName) .UseSerilog(); //调用Serilog,覆盖掉CreateDefaultBuilder中的默认配置  }   ","description":"","id":18,"section":"code","tags":null,"title":"03_日志","uri":"https://xtddw.github.io/code/dotnetcore/03%E6%97%A5%E5%BF%97logger/"},{"content":" 配置提供商  文件格式(INI, JSON, XML) 命令行参数 环境变量 内存中的.NET对象 未加密的Secret管理存储 加密的用户存储, 例如Azure秘钥库 自定义的提供商   JSON配置文件  默认 appsettings.json 注意：后加载的值会覆盖。\n 取得配置  IConfiguration[“Key:ChildKey”] 针对”ConnectionStrings:xxx”, 可以使用IConfiguration. GetConnectionString(“xxx”)      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public static IConfiguration Configuration; public StartupDevelopment(IConfiguration configuration) { Configuration = configuration; } public void ConfigureServices(IServiceCollection services) { services.AddMvc(); //注册Dbcontxt  services.AddDbContext\u0026lt;ApplicationContext\u0026gt;(options =\u0026gt; { //var connectionString = \u0026#34;Data Source = 10.30.0.14; Database = Blog.db; User = sa; Password = Hello,MMOC\u0026#34;;  //var connectionString = \u0026#34;Data Source = .;Database = Blog.db;Integrated Security=True\u0026#34;;  //var connectionString = Configuration[\u0026#34;ConnectionStrings:DefaultConnection\u0026#34;];  var connectionString = Configuration.GetConnectionString(\u0026#34;DefaultConnection\u0026#34;); options.UseSqlServer(connectionString); }); ... }    其他文件配置\nConfigurationBuilder().AddJsonFile(\u0026ldquo;appsettings.json\u0026rdquo;).Build() 返回IConfigurationRoot，继承于IConfiguration. 使用接口IConfiguration即可。  ","description":"","id":19,"section":"code","tags":null,"title":"04_项目配置","uri":"https://xtddw.github.io/code/dotnetcore/04%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/"},{"content":"默认异常处理 1  app.UseDeveloperExceptionPage();   自定义异常处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public static class ExceptionHandlingExtensions { public static void UseMyExceptionHandler(this IApplicationBuilder app,ILoggerFactory loggerFactory) { app.UseExceptionHandler(build =\u0026gt; { build.Run(async context =\u0026gt; { context.Response.StatusCode = StatusCodes.Status500InternalServerError; context.Response.ContentType = \u0026#34;application/json\u0026#34;; var ex = context.Features.Get\u0026lt;IExceptionHandlerFeature\u0026gt;(); if (ex != null) { var logger = loggerFactory.CreateLogger(\u0026#34;Blog.Api.Extensions.ExceptionHandlingExtensions\u0026#34;); logger.LogError(500, ex.Error, ex.Error.Message); } await context.Response.WriteAsync(ex?.Error?.Message ?? \u0026#34;An Error Occurred.\u0026#34;); }); }); } }   1 2 3 4 5 6  public void Configure(IApplicationBuilder app,ILoggerFactory loggerFactory) { app.UseMyExceptionHandler(loggerFactory); app.UseHttpsRedirection(); app.UseMvc(); }   ","description":"","id":20,"section":"code","tags":null,"title":"05_异常处理","uri":"https://xtddw.github.io/code/dotnetcore/05%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"content":"API 不应直接返回Entity  * Entity/Domain Model是内部实现细节 * 合约/接口界面  API应返回另外一个类（资源 Resource）  与Entity可能很像. 独立于Entity, 单独进化和改变. 也可以叫做ViewModel, Dto  Entity与Resoucre之间映射[AutoMapper]  安装Nuget包:\nAutoMapper\nAutoMapper.Extensions.Microsoft.DependencyInjection \u0026raquo;\u0026gt; API 配置映射\n可以创建Profile\nCreateMap\u0026lt;TSource, TDestination\u0026gt;()  1 2 3 4 5 6 7 8 9  public class MappingProfile:Profile { public MappingProfile() { CreateMap\u0026lt;Post, PostResource\u0026gt;() .ForMember(dest =\u0026gt; dest.UpdateTime, opt =\u0026gt; opt.MapFrom(src =\u0026gt; src.LastModified)); CreateMap\u0026lt;PostResource,Post\u0026gt;(); } }    services.AddAutoMapper() 依赖注入AutoMapper  1 2 3 4 5 6 7  [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get() { var posts = await _postRepository.GetAllPostsAsync(); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;,IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(posts); return Ok(postResources); }   ","description":"","id":21,"section":"code","tags":null,"title":"06_ResourceModel","uri":"https://xtddw.github.io/code/dotnetcore/06resourcemodel/"},{"content":"属性标签 https://docs.microsoft.com/zh-cn/aspnet/core/mvc/models/validation?view=aspnetcore-2.1\n [CreditCard]：验证属性是否具有信用卡格式。 [Compare]：验证某个模型中的两个属性是否匹配。 [EmailAddress]：验证属性是否具有电子邮件格式。 [Phone]：验证属性是否具有电话格式。 [Range]：验证属性值是否落在给定范围内。 [RegularExpression]：验证数据是否与指定的正则表达式匹配。 [Required]：将属性设置为必需属性。 [StringLength]：验证字符串属性是否最多具有给定的最大长度。 [Url]：验证属性是否具有 URL 格式。  FluentValidation  验证逻辑与业务逻辑分离 灵活, 功能强大\nFluent API, Lambda表达式 安装Nuget包:\nFluentValidation\nFluentValidation.AspNetCore 为Resource配置验证器\n继承于AbstractValidator  1 2 3 4 5 6 7 8 9 10 11 12  public class PostResourceValidator:AbstractValidator\u0026lt;PostResource\u0026gt; { public PostResourceValidator() { RuleFor(x =\u0026gt; x.Author) .NotNull() .WithName(\u0026#34;作者\u0026#34;) .WithMessage(\u0026#34;{PropertyName}是必填的\u0026#34;) .MaximumLength(20) .WithMessage(\u0026#34;{PropertyName}的最大长度是{MaxLength}\u0026#34;); } }   注册到容器: services.AddTransient\u0026lt;\u0026gt;()  1 2  //注册FluentValidator  services.AddTransient\u0026lt;IValidator\u0026lt;PostResource\u0026gt;, PostResourceValidator\u0026gt;();   ","description":"","id":22,"section":"code","tags":null,"title":"07_模型验证","uri":"https://xtddw.github.io/code/dotnetcore/07%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81/"},{"content":"什么是REST REST 是 Representational State Transfer 的缩写. 它是一种架构的风格, 这种风格基于一套预定义的规则, 这些规则描述了网络资源是如何定义和寻址的.\n一个实现了REST这些规则的服务就叫做RESTful的服务.\nREST的原则/约束 REST有6大原则/约束, 每一个原则都是对API有正面或负面影响的设计决定.\nRESTful API 最关心的有这几方面: 性能, 可扩展性, 简洁性, 互操作性, 通讯可见性, 组件便携性和可靠性.\n这些方面被封装在REST的6个原则里, 它们是:\n 客服端-服务端约束: 客户端和服务端是分离的, 它们可以独自的进化. 无状态: 客户端和服务段的通信必须是无状态的, 状态应包含在请求里的. 也就是说请求里要包含服务端需要的所有的信息, 以便服务端可以理解请求并可以创造上下文. 分层系统: 就像其它的软件架构一样, REST也需要分层结构, 但是不允许某层直接访问不相邻的层. 统一接口: 这里分为4点, 他们是: 资源标识符(URI), 资源的操作(也就是方法Method, HTTP动词), 自描述的响应(可以认为是媒体类型Media-Type), 以及状态管理(超媒体作为应用状态的引擎 HATEOAS, Hypermedia as the Engine of Application State). 缓存: 缓存约束派生于无状态约束, 它要求从服务端返回的响应必须明确表明是可缓存的还是不可缓存的. 按需编码: 这允许客户端可以从服务端访问特定的资源而无须知晓如何处理它们. 服务端可以扩展或自定义客户端的功能.  只有满足了这6个原则的系统才可以真正称得上是RESTful的, 其实大部分系统的RESTful API并不是RESTful的, 但这样并不代表这些API就不好, 利弊需要开发人员去衡量.\nRichardson 成熟度模型 Richardson 成熟度模型代表着你的API是否足够成熟, 分为4个级别, 0代表最差, 3代表最好.\n  0级, Plain Old XML沼泽:\n这里HTTP协议只是被用来进行远程交互, 协议的其余部分都用错了, 都是RPC风格的实现(例如SOAP, 尤其是使用WCF的时候).\n例如:\nPOST (查询数据信息)\nhttp://host/myapi\nPOST (创建数据)\nhttp://host/myapi\n  1级, 资源:\n这级里, 每个资源都映射到一个URI上了, 但是HTTP方法并没有正确的使用, 结果的复杂度不算太高.\n例如这两个查询:\nPOST\nhttp://host/api/authors\nPOST\nhttp://host/api/authors/{id}\n  2级, 动词:\n正确使用了HTTP动词, 状态码也正确的使用了, 同时也去掉了不必要的变种.\n例如:\nGET\nhttp://host/api/authors\nOk (authors)\nPOST (author representation)\nhttp://host/api/authors\nCreated (author)\n  3级, 超媒体:\nAPI支持超媒体作为应用状态的引擎 HATEOAS, Hypermedia as the Engine of Application State, 引入了可发现性.\n例如:\nGET\nhttp://host/api/authors\n200 Ok (返回了authors 和 驱动应用程序的超链接)\n  API 资源命名  资源应该使用名词, 它是个东西, 不是动作\nGET api/users 就是正确的\nGET api/users/{userId}. 层次结构\n例如 api/department/{departmentId}/emoloyees, 这就表示了department (部门)和员工(employee)之前是主从关系.\n而 api/department/{departmentId}/emoloyees/{employeeId}, 就表示了该部门下的某个员工. 过滤排序\n过滤和排序, 不是资源, 应作为参数.例如 api/users?orderby=username ID\n资源的URI应该永远都是一样的.\n推荐GUID应该作为ID来使用.\n自增int类型的ID, 在迁移到新数据库时需要特殊设定, 保证ID值不会发生变化.  HTTP方法与资源交互 注意:\n HEAD: 和GET差不多, 但是它不应该返回响应的body, 所以没有响应的payload. 它主要使用来获取资源的一些信息, 例如查看资源是否可用等. OPTIONS: 它是用来查询某个资源URI的可交互方式有哪些, 换句话说就是, 使用它可以知道某个URI是否可以执行GET或者POST动作, 这些结果通常是在响应的Headers里面而不是body里, 所以也没有响应的payload.  状态码  状态码会告诉API的消费者:  请求是否如预期的成功，或者失败 如果出现了错误，谁该为这个错误负责   API主要用到:  200级别, 表示成功.\n* 200 - OK\n* 201 - Created，表示资源创建成功了\n* 204 - No content，成功执行，但是不应该返回任何东西 400级别, 表示客户端引起的错误.\n* 400 - Bad request，表示API的消费者发送到服务器的请求是错误的\n* 401 - Unauthorized，表示没有权限\n* 403 - Forbidden，表示用户验证成功，但是该用户仍然无法访问该资源\n* 404 - Not found，表示请求的资源不存在\n* 405 - Method not allowed，这就是当我们尝试发送请求给某个资源时，使用的HTTP方法却是不允许的，例如使用POST api/countries, 而该资源只实现了 GET，所以POST不被允许\n* 406 - Not acceptable，这里涉及到了media type，例如API消费者请求的是application/xml格式的media type，而API只支持application/json\n* 409 - Conflict，表示该请求无法完成，因为请求与当前资源的状态有冲突，例如你编辑某个资源数据以后，该资源又被其它人更新了，这时你再PUT你的数据就会出现409错误；有时也用在尝试创建资源时该资源已存在的情况。\n* 415 - Unsupported media type，这个和406正好返回来，比如说我向服务器提交数据的media type是xml的，而服务器只支持json，那么就会返回415\n* 422 - Unprocessable entity，表示请求的格式没问题，但是语义有错误，例如实体验证错误。 500级别, 表示服务器错误.\n* 500 - Internal server error，这表示是服务器发生了错误    HTTP GET  单个数据\n找到了: 200\n没找到: 404  1 2 3 4 5 6 7 8 9 10 11  [HttpGet(\u0026#34;{id}\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get(int id) { var post = await _postRepository.GetPostByIdAsync(id); if (post == null) { return NotFound();//404  } var postResource = _mapper.Map\u0026lt;Post, PostResource\u0026gt;(post); return Ok(postResource); //200  }    集合数据\n至少有一条数据, 200\n没有数据, 也是200  1 2 3 4 5 6 7  [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get() { var posts = await _postRepository.GetAllPostsAsync(); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(posts); return Ok(postResources); }   内容协商 如果资源支持多种展现格式，那么消费者可以选择它想要的格式\n 在请求的Accept Header指定Media Type\n* application/json, application/xml\n* 若未指定, 返回默认 application/json 请求的media type不可用时, 并且消费者不支持默认格式, 返回406 ASP.NET Core支持输出和输入两种格式化器.\n* 用于输出的media type放在Accept Header里, 表示客户端接受这种格式的输出.\n* 用于输入的media type放Content-Type Header里, 表示客户端传进来的数据是这种格式.\n* ReturnHttpNotAcceptable设为true, 就会返回406.  1 2 3 4 5 6  services.AddMvc( options=\u0026gt; { options.ReturnHttpNotAcceptable = true; //开启406  options.OutputFormatters.Add(new XmlDataContractSerializerOutputFormatter()); });   ","description":"","id":23,"section":"code","tags":null,"title":"08_RESTful API","uri":"https://xtddw.github.io/code/dotnetcore/08rest/"},{"content":"翻页  Query String\nhttp://localhost:5000/api/posts?pageIndex=1\u0026amp;pageSize=10\u0026amp;orderBy=id 使用抽象父类 QueryParameters, 包含常见参数:\nPageIndex PageSize OrderBy…  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  public abstract class QueryParameters : INotifyPropertyChanged { private const int DefaultPageSize = 10; private const int DefaultMaxPageSize = 100; private int _pageIndex; public int PageIndex { get { return _pageIndex; } set { _pageIndex = value \u0026gt;= 0 ? value : 0; } } private int _pageSize; public virtual int PageSize { get { return _pageSize; } set =\u0026gt; SetField(ref _pageSize, value); } private string _orderBy; public string OrderBy { get { return _orderBy; } set { _orderBy = value ?? nameof(IEntity.Id); } } private int _maxPageSize = DefaultMaxPageSize; protected internal virtual int MaxPageSize { get { return _maxPageSize; } set =\u0026gt; SetField(ref _maxPageSize, value); } public string Fields { get; set; } public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } protected bool SetField\u0026lt;T\u0026gt;(ref T field, T value, [CallerMemberName] string propertyName = null) { if (EqualityComparer\u0026lt;T\u0026gt;.Default.Equals(field, value)) { return false; } field = value; OnPropertyChanged(propertyName); if (propertyName == nameof(PageSize) || propertyName == nameof(MaxPageSize)) { SetPageSize(); } return true; } private void SetPageSize() { if (_maxPageSize\u0026lt;=0) { _maxPageSize = DefaultMaxPageSize; } if (_pageSize\u0026lt;=0) { _pageSize = DefaultPageSize; } _pageSize = _pageSize \u0026gt; _maxPageSize ? _maxPageSize : _pageSize; } }   子类继承  1 2 3  public class PostParameters:QueryParameters { }   HTTP Get 传参  1 2 3 4 5 6 7  [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get(PostParameters postParameters) { var posts = await _postRepository.GetAllPostsAsync(postParameters); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(posts); return Ok(postResources); }   修改Repositroy  1 2 3 4 5 6 7 8 9  public async Task\u0026lt;IEnumerable\u0026lt;Post\u0026gt;\u0026gt; GetAllPostsAsync(PostParameters postParameters) { var query = _applicationContext.Posts.OrderBy(x =\u0026gt; x.Id); return await query .Skip(postParameters.PageIndex * postParameters.PageSize) .Take(postParameters.PageSize) .ToListAsync(); }   返回翻页元数据  如果将数据和翻页元数据一起返回:\n* * 响应的body不再符合Accept Header了(不是资源的application/json), 这是一种新的media type.\n* 违反REST约束, API消费者不知道如何通过application/json这个类型来解释响应的数据. 翻页数据不是资源表述的一部分, 应使用自定义Header (X-Pagination). 存放翻页数据的类: PaginatedList可以继承于List.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public class PaginatedList\u0026lt;T\u0026gt;:List\u0026lt;T\u0026gt; where T:class { public int PageSize { get; set; } public int PageIndex { get; set; } private int _totalItemsCount; public int TotalItemsCount { get { return _totalItemsCount; } set { _totalItemsCount = value; } } public int PageCount =\u0026gt; TotalItemsCount / PageSize + (TotalItemsCount % PageSize \u0026gt; 0 ? 1 : 0); public bool HasPrevious =\u0026gt; PageIndex \u0026gt; 0; public bool HasNext =\u0026gt; PageIndex \u0026lt; PageCount - 1; public PaginatedList(int pageIndex,int pageSize,int totalItemsCount,IEnumerable\u0026lt;T\u0026gt; data) { PageIndex = pageIndex; PageSize = pageSize; TotalItemsCount = totalItemsCount; AddRange(data); } }   修改Repository\n1 2 3 4 5 6 7 8 9 10 11  public async Task\u0026lt;PaginatedList\u0026lt;Post\u0026gt;\u0026gt; GetAllPostsAsync(PostParameters postParameters) { var query = _applicationContext.Posts.OrderBy(x =\u0026gt; x.Id); var count = await query.CountAsync(); var data = await query .Skip(postParameters.PageIndex * postParameters.PageSize) .Take(postParameters.PageSize) .ToListAsync(); return new PaginatedList\u0026lt;Post\u0026gt;(postParameters.PageIndex, postParameters.PageSize, count, data); }   修改controller\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  [HttpGet] public async Task\u0026lt;IActionResult\u0026gt; Get(PostParameters postParameters) { var postList = await _postRepository.GetAllPostsAsync(postParameters); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(postList); var meta = new { postList.PageSize, postList.PageIndex, postList.TotalItemsCount, postList.PageCount }; Response.Headers.Add(\u0026#34;X-Pagination\u0026#34;, JsonConvert.SerializeObject(meta, new JsonSerializerSettings { //使得命名符合驼峰命名法  ContractResolver = new CamelCasePropertyNamesContractResolver() })); return Ok(postResources); }   生成前后页的URI  枚举UriType  1 2 3 4 5 6  public enum PaginationResourceUriType { CurrentPage, PreviousPage, NextPage }   注册UrlHelper  1 2 3 4 5 6 7  //注册UrlHelper services.AddSingleton\u0026lt;IActionContextAccessor, ActionContextAccessor\u0026gt;(); services.AddScoped\u0026lt;IUrlHelper\u0026gt;(factory =\u0026gt; { var actionContext = factory.GetService\u0026lt;IActionContextAccessor\u0026gt;().ActionContext; return new IUrlHelper(actionContext); });   创建CreatePostUri()方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  private string CreatePostUri(PostParameters parameters,PaginationResourceUriType uriType) { switch(uriType) { case PaginationResourceUriType.PreviousPage: var previousParameters = new { pageIndex = parameters.PageIndex - 1, pagesize = parameters.PageSize, orderBy = parameters.OrderBy, fields = parameters.Fields }; return _urlHelper.Link(\u0026#34;GetPosts\u0026#34;, previousParameters); case PaginationResourceUriType.NextPage: var nextParameters = new { pageIndex = parameters.PageIndex + 1, pagesize = parameters.PageSize, orderBy = parameters.OrderBy, fields = parameters.Fields }; return _urlHelper.Link(\u0026#34;GetPosts\u0026#34;, nextParameters); default: var currentParameters = new { pageIndex = parameters.PageIndex, pagesize = parameters.PageSize, orderBy = parameters.OrderBy, fields = parameters.Fields }; return _urlHelper.Link(\u0026#34;GetPosts\u0026#34;, currentParameters); } }   修改Get方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  [HttpGet(Name =\u0026#34;GetPosts\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get(PostParameters postParameters) { var postList = await _postRepository.GetAllPostsAsync(postParameters); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(postList); var previousPageLink = postList.HasPrevious ? CreatePostUri(postParameters, PaginationResourceUriType.PreviousPage) : null; var nextPageLink = postList.HasNext ? CreatePostUri(postParameters, PaginationResourceUriType.NextPage) : null; var meta = new { postList.PageSize, postList.PageIndex, postList.TotalItemsCount, postList.PageCount, previousPageLink, nextPageLink }; Response.Headers.Add(\u0026#34;X-Pagination\u0026#34;, JsonConvert.SerializeObject(meta, new JsonSerializerSettings { //使得命名符合驼峰命名法  ContractResolver = new CamelCasePropertyNamesContractResolver() })); return Ok(postResources); }   过滤和搜索  过滤: 对集合资源附加一些条件, 筛选出结果.\nhttp://localhost:5000/api/posts?title=China\n条件应用于Resource Model.\n过滤属性可以放在QueryParameters的子类里.  1 2 3 4  public class PostParameters:QueryParameters { public string Title { get; set; } }   修改Repository\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public async Task\u0026lt;PaginatedList\u0026lt;Post\u0026gt;\u0026gt; GetAllPostsAsync(PostParameters postParameters) { var query = _applicationContext.Posts.AsQueryable(); if (!string.IsNullOrEmpty(postParameters.Title)) { var title = postParameters.Title.ToLowerInvariant(); query = query.Where(x =\u0026gt; x.Title.ToLowerInvariant()==title); } query = query.OrderBy(x =\u0026gt; x.Id); var count = await query.CountAsync(); var data = await query .Skip(postParameters.PageIndex * postParameters.PageSize) .Take(postParameters.PageSize) .ToListAsync(); return new PaginatedList\u0026lt;Post\u0026gt;(postParameters.PageIndex, postParameters.PageSize, count, data); }    搜索: 使用关键字对集合资源进行模糊搜索.\nhttp://localhost/api/posts?searchTerm=hin  排序  问题\n翻页需要排序.\n让资源按照资源的某个属性或多个属性进行正向或反向的排序.\nResource Model的一个属性可能会映射到Entity Model的多个属性上\nResource Model上的正序可能在Entity Model上就是倒序的\n需要支持多属性的排序\n复用 安装System.Linq.Dynamic.Core 排序异常返回400BadRequest 排序思路   PropertyMappingContainer\n* PropertyMapping (PostPropertyMapping)\n* MappedProperty\n  MappedProperty 1 2 3 4 5  public class MappedProperty { public string Name { get; set; } public bool Revert { get; set; } }   PropertyMapping 1 2 3 4  public interface IPropertyMapping { Dictionary\u0026lt;string, List\u0026lt;MappedProperty\u0026gt;\u0026gt; MappingDictionary { get; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  public abstract class PropertyMapping\u0026lt;TSource,TDestination\u0026gt;:IPropertyMapping where TDestination:IEntity { //可能映射多个Entity中属性，所以使用List\u0026lt;MappedProperty\u0026gt;  public Dictionary\u0026lt;string,List\u0026lt;MappedProperty\u0026gt;\u0026gt; MappingDictionary { get; } protected PropertyMapping(Dictionary\u0026lt;string,List\u0026lt;MappedProperty\u0026gt;\u0026gt; mappingDictionary) { MappingDictionary = mappingDictionary; MappingDictionary[nameof(IEntity.Id)] = new List\u0026lt;MappedProperty\u0026gt; { new MappedProperty{Name=nameof(IEntity.Id),Revert =false} }; } }    PostPropertyMapping  1 2 3 4 5 6 7 8 9 10 11 12  public class PostPropertyMapping : PropertyMapping\u0026lt;PostResource, Post\u0026gt; { public PostPropertyMapping() : base(new Dictionary\u0026lt;string, List\u0026lt;MappedProperty\u0026gt;\u0026gt;(StringComparer.OrdinalIgnoreCase) { [nameof(PostResource.Title)] = new List\u0026lt;MappedProperty\u0026gt; { new MappedProperty { Name=nameof(Post.Title),Revert=false}}, [nameof(PostResource.Body)] = new List\u0026lt;MappedProperty\u0026gt; { new MappedProperty { Name=nameof(Post.Body),Revert=false}}, [nameof(PostResource.Author)] = new List\u0026lt;MappedProperty\u0026gt; { new MappedProperty { Name=nameof(Post.Author),Revert=false}}, }) { }   PropertyMappingContainer 1 2 3 4 5 6  public interface IPropertyMappingContainer { void Register\u0026lt;T\u0026gt;() where T : IPropertyMapping, new(); IPropertyMapping Resolve\u0026lt;TSource, TDestination\u0026gt;() where TDestination : IEntity; bool ValidateMappingExistsFor\u0026lt;TSource, TDestination\u0026gt;(string fields) where TDestination : IEntity; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  public class PropertyMappingContainer : IPropertyMappingContainer { protected internal readonly IList\u0026lt;IPropertyMapping\u0026gt; PropertyMappings = new List\u0026lt;IPropertyMapping\u0026gt;(); public void Register\u0026lt;T\u0026gt;() where T : IPropertyMapping, new() { if (PropertyMappings.All(x=\u0026gt;x.GetType()!=typeof(T))) { PropertyMappings.Add(new T()); } } //注册  public IPropertyMapping Resolve\u0026lt;TSource, TDestination\u0026gt;() where TDestination : IEntity { var matchingMapping = PropertyMappings.OfType\u0026lt;PropertyMapping\u0026lt;TSource, TDestination\u0026gt;\u0026gt;().ToList(); if (matchingMapping.Count ==1) { return matchingMapping.First(); } throw new Exception($\u0026#34;Cannot find property mapping instance for {typeof(TSource)},{typeof(TDestination)}\u0026#34;); } //验证  public bool ValidateMappingExistsFor\u0026lt;TSource, TDestination\u0026gt;(string fields) where TDestination : IEntity { var propertyMapping = Resolve\u0026lt;TSource, TDestination\u0026gt;(); if (string.IsNullOrWhiteSpace(fields)) { return false; } var fieldsAfterSplit = fields.Split(\u0026#39;,\u0026#39;); foreach (var field in fieldsAfterSplit) { var trimedField = field.Trim(); var indexOfFirstSpace = trimedField.IndexOf(\u0026#34; \u0026#34;, StringComparison.Ordinal); var propertyName = indexOfFirstSpace == -1 ? trimedField : trimedField.Remove(indexOfFirstSpace); if (string.IsNullOrWhiteSpace(propertyName)) { continue; } if (!propertyMapping.MappingDictionary.ContainsKey(propertyName)) { return false; } } return true; } }   注册服务 1 2 3 4 5 6 7  //注册排序服务  //1.新建一个容器 var propertyMappingContainer = new PropertyMappingContainer(); //2.把PostPropertyMapping注册 propertyMappingContainer.Register\u0026lt;PostPropertyMapping\u0026gt;(); //3.注册单例容器 services.AddSingleton\u0026lt;IPropertyMappingContainer\u0026gt;(propertyMappingContainer);   QueryableExtensions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95  public static class QueryableExtensions { public static IQueryable\u0026lt;T\u0026gt; ApplySort\u0026lt;T\u0026gt;(this IQueryable\u0026lt;T\u0026gt; source, string orderBy, IPropertyMapping propertyMapping) { if (source ==null) throw new ArgumentNullException(nameof(source)); if (propertyMapping == null) throw new ArgumentNullException(nameof(propertyMapping)); var mappingDictionary = propertyMapping.MappingDictionary; if (mappingDictionary ==null) throw new ArgumentNullException(nameof(mappingDictionary)); if (string.IsNullOrWhiteSpace(orderBy)) return source; var orderByAfterSplit = orderBy.Split(\u0026#39;,\u0026#39;); foreach (var orderByClause in orderByAfterSplit.Reverse()) { var trimedOrderByClause = orderByClause.Trim(); var orderDescending = trimedOrderByClause.EndsWith(\u0026#34; desc\u0026#34;); var indexOfFirstSpace = trimedOrderByClause.IndexOf(\u0026#34; \u0026#34;, StringComparison.Ordinal); var propertyName = indexOfFirstSpace == -1 ? trimedOrderByClause : trimedOrderByClause.Remove(indexOfFirstSpace); if (string.IsNullOrEmpty(propertyName)) continue; if (!mappingDictionary.TryGetValue(propertyName,out List\u0026lt;MappedProperty\u0026gt; mappedProperties)) throw new ArgumentNullException($\u0026#34;Key mapping for {propertyName} is missing\u0026#34;); if (mappedProperties == null) throw new ArgumentNullException(propertyName); mappedProperties.Reverse(); foreach (var destinationProperty in mappedProperties) { if (destinationProperty.Revert) { orderDescending = !orderDescending; } source = source.OrderBy(destinationProperty.Name + (orderDescending ? \u0026#34; descending\u0026#34; : \u0026#34; ascending\u0026#34;)); //OrderBy =====\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; System.Linq.Dynamic.Core;  } } return source; } public static IQueryable\u0026lt;object\u0026gt; ToDynamicQueryable\u0026lt;TSource\u0026gt; (this IQueryable\u0026lt;TSource\u0026gt; source, string fields, Dictionary\u0026lt;string, List\u0026lt;MappedProperty\u0026gt;\u0026gt; mappingDictionary) { if (source == null) { throw new ArgumentNullException(nameof(source)); } if (mappingDictionary == null) { throw new ArgumentNullException(nameof(mappingDictionary)); } if (string.IsNullOrWhiteSpace(fields)) { return (IQueryable\u0026lt;object\u0026gt;)source; } fields = fields.ToLower(); var fieldsAfterSplit = fields.Split(\u0026#39;,\u0026#39;).ToList(); if (!fieldsAfterSplit.Contains(\u0026#34;id\u0026#34;, StringComparer.InvariantCultureIgnoreCase)) { fieldsAfterSplit.Add(\u0026#34;id\u0026#34;); } var selectClause = \u0026#34;new (\u0026#34;; foreach (var field in fieldsAfterSplit) { var propertyName = field.Trim(); if (string.IsNullOrEmpty(propertyName)) { continue; } var key = mappingDictionary.Keys.SingleOrDefault(k =\u0026gt; String.CompareOrdinal(k.ToLower(), propertyName.ToLower()) == 0); if (string.IsNullOrEmpty(key)) { throw new ArgumentException($\u0026#34;Key mapping for {propertyName} is missing\u0026#34;); } var mappedProperties = mappingDictionary[key]; if (mappedProperties == null) { throw new ArgumentNullException(key); } foreach (var destinationProperty in mappedProperties) { selectClause += $\u0026#34; {destinationProperty.Name},\u0026#34;; } } selectClause = selectClause.Substring(0, selectClause.Length - 1) + \u0026#34;)\u0026#34;; return (IQueryable\u0026lt;object\u0026gt;)source.Select(selectClause); } }   修改Repository 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public async Task\u0026lt;PaginatedList\u0026lt;Post\u0026gt;\u0026gt; GetAllPostsAsync(PostParameters postParameters) { var query = _applicationContext.Posts.AsQueryable(); if (!string.IsNullOrEmpty(postParameters.Title)) { var title = postParameters.Title.ToLowerInvariant(); query = query.Where(x =\u0026gt; x.Title.ToLowerInvariant()==title); } //调用排序  //query = query.OrderBy(x =\u0026gt; x.Id);  query = query.ApplySort(postParameters.OrderBy, _propertyMappingContainer.Resolve\u0026lt;PostResource, Post\u0026gt;()); var count = await query.CountAsync(); var data = await query .Skip(postParameters.PageIndex * postParameters.PageSize) .Take(postParameters.PageSize) .ToListAsync(); return new PaginatedList\u0026lt;Post\u0026gt;(postParameters.PageIndex, postParameters.PageSize, count, data); }   ","description":"","id":24,"section":"code","tags":null,"title":"09_翻页过滤排序","uri":"https://xtddw.github.io/code/dotnetcore/09%E7%BF%BB%E9%A1%B5%E8%BF%87%E6%BB%A4%E6%8E%92%E5%BA%8F/"},{"content":"资源塑形 如果资源的属性较多, 而且API消费者只需要一分部属性, 那么就应该考虑资源塑形\n集合资源 单个资源 异常处理\n IEnumerableExtensions  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  //集合资源塑性  public static class IEnumerableExtensions { public static IEnumerable\u0026lt;ExpandoObject\u0026gt; ToDynamicIEnumerable\u0026lt;TSource\u0026gt;(this IEnumerable\u0026lt;TSource\u0026gt; source,string fields = null) { if (source ==null) { throw new ArgumentNullException(nameof(source)); } var expandoObjectList = new List\u0026lt;ExpandoObject\u0026gt;(); var propertyInfoList = new List\u0026lt;PropertyInfo\u0026gt;(); if (string.IsNullOrWhiteSpace(fields)) { var propertyInfos = typeof(TSource).GetProperties(BindingFlags.Public | BindingFlags.Instance); propertyInfoList.AddRange(propertyInfos); } else { var fieldsAfterSplit = fields.Split(\u0026#39;,\u0026#39;).ToList(); foreach (var field in fieldsAfterSplit) { var propertyName = field.Trim(); if (string.IsNullOrEmpty(propertyName)) { continue; } var propertyInfo = typeof(TSource).GetProperty(propertyName, BindingFlags.IgnoreCase | BindingFlags.Public | BindingFlags.Instance); if (propertyInfo ==null) { throw new Exception($\u0026#34;Property {propertyName} was\u0026#39;t found on {typeof(TSource)}\u0026#34;); } propertyInfoList.Add(propertyInfo); } } foreach (TSource sourceObject in source) { var dataShapedObject = new ExpandoObject(); foreach (var propertyInfo in propertyInfoList) { var propertyValue = propertyInfo.GetValue(sourceObject); ((IDictionary\u0026lt;string, object\u0026gt;)dataShapedObject).Add(propertyInfo.Name, propertyValue); } expandoObjectList.Add(dataShapedObject); } return expandoObjectList; } }   ObjectExtensions  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  //单个资源塑性  public static class ObjectExtensions { public static ExpandoObject ToDynamic\u0026lt;TSoucre\u0026gt;(this TSoucre source,string fields = null) { if (source == null) { throw new ArgumentNullException(nameof(source)); } var dataShapedObject = new ExpandoObject(); if (string.IsNullOrWhiteSpace(fields)) { var propertyInfos = typeof(TSoucre).GetProperties(BindingFlags.IgnoreCase | BindingFlags.Public | BindingFlags.Instance); foreach (var propertyInfo in propertyInfos) { var propertyValue = propertyInfo.GetValue(source); ((IDictionary\u0026lt;string, object\u0026gt;)dataShapedObject).Add(propertyInfo.Name, propertyValue); } return dataShapedObject; } var fieldsAfterSplit = fields.Split(\u0026#39;,\u0026#39;).ToList(); foreach (var field in fieldsAfterSplit) { var propertyName = field.Trim(); var propertyInfo = typeof(TSoucre).GetProperty(propertyName, BindingFlags.IgnoreCase | BindingFlags.Public | BindingFlags.Instance); if (propertyInfo ==null) { throw new Exception($\u0026#34;Can\u0026#39;t found property {typeof(TSoucre)} on {propertyName}\u0026#34;); } var propertyValue = propertyInfo.GetValue(source); ((IDictionary\u0026lt;string, object\u0026gt;)dataShapedObject).Add(propertyInfo.Name, propertyValue); } return dataShapedObject; } }   修改controller  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  [HttpGet(Name =\u0026#34;GetPosts\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get(PostParameters postParameters) { var postList = await _postRepository.GetAllPostsAsync(postParameters); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(postList); //集合资源塑性  var shapedPostResources = postResources.ToDynamicIEnumerable(postParameters.Fields); var previousPageLink = postList.HasPrevious ? CreatePostUri(postParameters, PaginationResourceUriType.PreviousPage) : null; var nextPageLink = postList.HasNext ? CreatePostUri(postParameters, PaginationResourceUriType.NextPage) : null; var meta = new { postList.PageSize, postList.PageIndex, postList.TotalItemsCount, postList.PageCount, previousPageLink, nextPageLink }; Response.Headers.Add(\u0026#34;X-Pagination\u0026#34;, JsonConvert.SerializeObject(meta, new JsonSerializerSettings { //使得命名符合驼峰命名法  ContractResolver = new CamelCasePropertyNamesContractResolver() })); return Ok(shapedPostResources);   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  [HttpGet(\u0026#34;{id}\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get(int id, string fields = null) { var post = await _postRepository.GetPostByIdAsync(id); if (post == null) { return NotFound();//404  } var postResource = _mapper.Map\u0026lt;Post, PostResource\u0026gt;(post); //单个资源塑性  var shapedPostResource = postResource.ToDynamic(fields); return Ok(shapedPostResource); //200  }   4. 修改startup,返回资源命名为驼峰命名\n1 2 3 4 5 6 7 8 9 10  services.AddMvc( options=\u0026gt; { options.ReturnHttpNotAcceptable = true; //开启406  options.OutputFormatters.Add(new XmlDataContractSerializerOutputFormatter()); }) .AddJsonOptions(options=\u0026gt; { options.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver(); });   异常处理  ITypeHelperService  1 2 3 4  public interface ITypeHelperService { bool TypeHasProperties\u0026lt;T\u0026gt;(string fields); }   TypeHelperService  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  public class TypeHelperService:ITypeHelperService { public bool TypeHasProperties\u0026lt;T\u0026gt;(string fields) { if (string.IsNullOrWhiteSpace(fields)) { return true; } var fieldsAfterSplit = fields.Split(\u0026#39;,\u0026#39;); foreach (var field in fieldsAfterSplit) { var propertyName = field.Trim(); if (string.IsNullOrEmpty(propertyName)) { continue; } var propertyInfo = typeof(T) .GetProperty(propertyName, BindingFlags.IgnoreCase | BindingFlags.Public | BindingFlags.Instance); if (propertyInfo == null) { return false; } } return true; } }   注册TypeHelperService  1  services.AddTransient\u0026lt;ITypeHelperService, TypeHelperService\u0026gt;();   修改Controller  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  [HttpGet(Name =\u0026#34;GetPosts\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get(PostParameters postParameters) { if (!_propertyMappingContainer.ValidateMappingExistsFor\u0026lt;PostResource,Post\u0026gt;(postParameters.OrderBy)) { return BadRequest(\u0026#34;cannot finds fields for sorting.\u0026#34;); } if (!_typeHelperService.TypeHasProperties\u0026lt;PostResource\u0026gt;(postParameters.Fields)) { return BadRequest(\u0026#34;Fields not exist.\u0026#34;); } var postList = await _postRepository.GetAllPostsAsync(postParameters); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(postList); //集合资源塑性  var shapedPostResources = postResources.ToDynamicIEnumerable(postParameters.Fields); var previousPageLink = postList.HasPrevious ? CreatePostUri(postParameters, PaginationResourceUriType.PreviousPage) : null; var nextPageLink = postList.HasNext ? CreatePostUri(postParameters, PaginationResourceUriType.NextPage) : null; var meta = new { postList.PageSize, postList.PageIndex, postList.TotalItemsCount, postList.PageCount, previousPageLink, nextPageLink }; Response.Headers.Add(\u0026#34;X-Pagination\u0026#34;, JsonConvert.SerializeObject(meta, new JsonSerializerSettings { //使得命名符合驼峰命名法  ContractResolver = new CamelCasePropertyNamesContractResolver() })); return Ok(shapedPostResources); } [HttpGet(\u0026#34;{id}\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get(int id, string fields = null) { if (!_typeHelperService.TypeHasProperties\u0026lt;PostResource\u0026gt;(fields)) { return BadRequest(\u0026#34;Fields not exist.\u0026#34;); } var post = await _postRepository.GetPostByIdAsync(id); if (post == null) { return NotFound();//404  } var postResource = _mapper.Map\u0026lt;Post, PostResource\u0026gt;(post); //单个资源塑性  var shapedPostResource = postResource.ToDynamic(fields); return Ok(shapedPostResource); //200  }   ","description":"","id":25,"section":"code","tags":null,"title":"10_资源塑形","uri":"https://xtddw.github.io/code/dotnetcore/10%E8%B5%84%E6%BA%90%E5%A1%91%E5%BD%A2/"},{"content":"Hypermedia as the Engine of Application State\nREST里最复杂的约束, 构建成熟REST API的核心\n 可进化性, 自我描述 超媒体(Hypermedia, 例如超链接)驱动如何消费和使用API  不使用HATEOAS  客户端更多的需要了解API内在逻辑 如果API发生了一点变化(添加了额外的规则, 改变规则)都会破坏API的消费者. API无法独立于消费它的应用进行进化.\n  使用HATEOAS  这个response里面包含了若干link, 第一个link包含着获取当前响应的链接, 第二个link则告诉客户端如何去更新该post. 不改变响应主体结果的情况下添加另外一个删除的功能(link), 客户端通过响应里的links就会发现这个删除功能, 但是对其他部分都没有影响.\n  展示链接  JSON和XML并没有如何展示link的概念. 但是HTML的anchor元素却知道: .  href包含了URI rel则描述了link如何和资源的关系 type是可选的, 它表示了媒体的类型   我们的例子:  method: 定义了需要使用的方法 rel: 表明了动作的类型 href: 包含了执行这个动作所包含的URI.\n    实现  静态基类\n需要基类(包含link)和包装类, 也就是返回的资源里面都含有link, 通过继承于同一个基类来实现 动态类型, 需要使用例如匿名类或ExpandoObject等\n* 对于单个资源可以使用ExpandoObject\n* 对于集合类资源则使用匿名类.   LinkResource  1 2 3 4 5 6 7 8 9 10 11 12  public class LinkResource { public LinkResource(string href,string rel,string method) { Href = href; Rel = rel; Method = method; } public string Href { get; set; } public string Rel { get; set; } public string Method { get; set; } }   Controller中添加CreateLinksForPost  1 2 3 4 5 6 7 8 9 10 11 12 13  //为每个资源创建链接link  private IEnumerable\u0026lt;LinkResource\u0026gt; CreateLinksForPost(int id,string fields = null) { var links = new List\u0026lt;LinkResource\u0026gt;(); if (string.IsNullOrWhiteSpace(fields)) links.Add(new LinkResource(_urlHelper.Link(\u0026#34;GetPost\u0026#34;, new { id }), \u0026#34;self\u0026#34;, \u0026#34;GET\u0026#34;)); else links.Add(new LinkResource(_urlHelper.Link(\u0026#34;GetPost\u0026#34;, new { id,fields}), \u0026#34;self\u0026#34;, \u0026#34;GET\u0026#34;)); links.Add(new LinkResource(_urlHelper.Link(\u0026#34;DeletePost\u0026#34;, new { id }), \u0026#34;delete_post\u0026#34;, \u0026#34;DELETE\u0026#34;)); return links; }   GETPOST中调用  1 2 3 4 5 6 7 8 9 10 11  //单个资源塑性 var shapedPostResource = postResource.ToDynamic(fields); //加载link var links = CreateLinksForPost(id, fields); //整合返回数据 var result = shapedPostResource as IDictionary\u0026lt;string, object\u0026gt;; result.Add(\u0026#34;links\u0026#34;, links); return Ok(result);   1 2 3 4 5 6 7 8 9 10 11  //集合资源塑性  var shapedPostResources = postResources.ToDynamicIEnumerable(postParameters.Fields); //循环遍历为每个资源添加link var shapdeWithLinks = shapedPostResources.Select(x =\u0026gt; { var dict = x as IDictionary\u0026lt;string, object\u0026gt;; var postLinks = CreateLinksForPost((int)dict[\u0026#34;Id\u0026#34;], postParameters.Fields); dict.Add(\u0026#34;links\u0026#34;, psotLinks); return dict; });   4. 集合资源整体Link\n1 2 3 4 5 6 7 8 9 10 11 12 13  //为集合资源创建整体link private IEnumerable\u0026lt;LinkResource\u0026gt; CreateLinksForPosts(PostParameters postParameters,bool hasPrevious,bool hasNext) { var links = new List\u0026lt;LinkResource\u0026gt; { new LinkResource(CreatePostUri(postParameters,PaginationResourceUriType.CurrentPage),\u0026#34;self\u0026#34;,\u0026#34;GET\u0026#34;) }; if (hasPrevious) links.Add(new LinkResource(CreatePostUri(postParameters,PaginationResourceUriType.PreviousPage),\u0026#34;previous_page\u0026#34;,\u0026#34;GET\u0026#34;)); if (hasNext) links.Add(new LinkResource(CreatePostUri(postParameters,PaginationResourceUriType.NextPage),\u0026#34;next_page\u0026#34;,\u0026#34;GET\u0026#34;)); return links; }   1 2 3 4 5 6 7 8  //集合的整体links var links = CreateLinksForPosts(postParameters, postList.HasPrevious, postList.HasNext); var result = new { values = shapdeWithLinks, links };   Vendor-specific media type 创建供应商特定媒体类型\n上例中使用application/json会破坏了资源的自我描述性这条约束, API消费者无法从content-type的类型来正确的解析响应.\n application/vnd.mycompany.hateoas+json\n* vnd是vendor的缩写，这一条是mime type的原则，表示这个媒体类型是供应商特定的  自定义的标识，也可能还包括额外的值，这里我是用的是公司名，随后是hateoas表示返回的响应里面要包含链接 +json   在Startup里注册.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  services.AddMvc( options=\u0026gt; { options.ReturnHttpNotAcceptable = true; //开启406  //支持xml  //options.OutputFormatters.Add(new XmlDataContractSerializerOutputFormatter());  //自定义mediaType  var outputFormatter = options.OutputFormatters.OfType\u0026lt;JsonOutputFormatter\u0026gt;().FirstOrDefault(); if (outputFormatter!=null) { outputFormatter.SupportedMediaTypes.Add(\u0026#34;application/vnd.enfi.hateoas+json\u0026#34;); } }) .AddJsonOptions(options=\u0026gt; { options.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver(); });    判断Media Type类型\n* [FromHeader(Name = \u0026ldquo;Accept\u0026rdquo;)] string mediaType\n* 自定义Action约束.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  [HttpGet(Name = \u0026#34;GetPosts\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Get(PostParameters postParameters, [FromHeader(Name = \u0026#34;Accept\u0026#34;)] string mediaType) { if (!_propertyMappingContainer.ValidateMappingExistsFor\u0026lt;PostResource, Post\u0026gt;(postParameters.OrderBy)) { return BadRequest(\u0026#34;cannot finds fields for sorting.\u0026#34;); } if (!_typeHelperService.TypeHasProperties\u0026lt;PostResource\u0026gt;(postParameters.Fields)) { return BadRequest(\u0026#34;Fields not exist.\u0026#34;); } var postList = await _postRepository.GetAllPostsAsync(postParameters); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(postList); //判断mediaType  if (mediaType == \u0026#34;application/vnd.enfi.hateoas+json\u0026#34;) { //集合资源塑性  var shapedPostResources = postResources.ToDynamicIEnumerable(postParameters.Fields); //循环遍历为每个资源添加link  var shapdeWithLinks = shapedPostResources.Select(x =\u0026gt; { var dict = x as IDictionary\u0026lt;string, object\u0026gt;; var postLinks = CreateLinksForPost((int)dict[\u0026#34;Id\u0026#34;], postParameters.Fields); dict.Add(\u0026#34;links\u0026#34;, postLinks); return dict; }); //集合的整体links  var links = CreateLinksForPosts(postParameters, postList.HasPrevious, postList.HasNext); var result = new { values = shapdeWithLinks, links }; //var previousPageLink = postList.HasPrevious ? CreatePostUri(postParameters, PaginationResourceUriType.PreviousPage) : null;  //var nextPageLink = postList.HasNext ? CreatePostUri(postParameters, PaginationResourceUriType.NextPage) : null;  var meta = new { postList.PageSize, postList.PageIndex, postList.TotalItemsCount, postList.PageCount, //previousPageLink,  //nextPageLink  }; Response.Headers.Add(\u0026#34;X-Pagination\u0026#34;, JsonConvert.SerializeObject(meta, new JsonSerializerSettings { //使得命名符合驼峰命名法  ContractResolver = new CamelCasePropertyNamesContractResolver() })); return Ok(result); } else //不是自定义的mediaType按json返回，元数据包含在返回的head中  { var previousPageLink = postList.HasPrevious ? CreatePostUri(postParameters, PaginationResourceUriType.PreviousPage) : null; var nextPageLink = postList.HasNext ? CreatePostUri(postParameters, PaginationResourceUriType.NextPage) : null; var meta = new { postList.PageSize, postList.PageIndex, postList.TotalItemsCount, postList.PageCount, previousPageLink, nextPageLink }; Response.Headers.Add(\u0026#34;X-Pagination\u0026#34;, JsonConvert.SerializeObject(meta, new JsonSerializerSettings { //使得命名符合驼峰命名法  ContractResolver = new CamelCasePropertyNamesContractResolver() })); return Ok(postResources.ToDynamicIEnumerable(postParameters.Fields)); } }   使用Action约束分解为两个方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  [AttributeUsage(AttributeTargets.All, Inherited = true, AllowMultiple = true)] public class RequestHeaderMatchingMediaTypeAttribute : Attribute, IActionConstraint { private readonly string _requestHeaderToMatch; private readonly string[] _mediaTypes; public RequestHeaderMatchingMediaTypeAttribute(string requestHeaderToMatch, string[] mediaTypes) { _requestHeaderToMatch = requestHeaderToMatch; _mediaTypes = mediaTypes; } public bool Accept(ActionConstraintContext context) { var requestHeaders = context.RouteContext.HttpContext.Request.Headers; if (!requestHeaders.ContainsKey(_requestHeaderToMatch)) { return false; } foreach (var mediaType in _mediaTypes) { var mediaTypeMatches = string.Equals(requestHeaders[_requestHeaderToMatch].ToString(), mediaType, StringComparison.OrdinalIgnoreCase); if (mediaTypeMatches) { return true; } } return false; } public int Order { get; } = 0; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  [HttpGet(Name = \u0026#34;GetPosts\u0026#34;)] [RequestHeaderMatchingMediaType(\u0026#34;Accept\u0026#34;, new[] { \u0026#34;application/vnd.enfi.hateoas+json\u0026#34; })] public async Task\u0026lt;IActionResult\u0026gt; GetHateoas(PostParameters postParameters) { if (!_propertyMappingContainer.ValidateMappingExistsFor\u0026lt;PostResource, Post\u0026gt;(postParameters.OrderBy)) { return BadRequest(\u0026#34;cannot finds fields for sorting.\u0026#34;); } if (!_typeHelperService.TypeHasProperties\u0026lt;PostResource\u0026gt;(postParameters.Fields)) { return BadRequest(\u0026#34;Fields not exist.\u0026#34;); } var postList = await _postRepository.GetAllPostsAsync(postParameters); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(postList); //集合资源塑性  var shapedPostResources = postResources.ToDynamicIEnumerable(postParameters.Fields); //循环遍历为每个资源添加link  var shapdeWithLinks = shapedPostResources.Select(x =\u0026gt; { var dict = x as IDictionary\u0026lt;string, object\u0026gt;; var postLinks = CreateLinksForPost((int)dict[\u0026#34;Id\u0026#34;], postParameters.Fields); dict.Add(\u0026#34;links\u0026#34;, postLinks); return dict; }); //集合的整体links  var links = CreateLinksForPosts(postParameters, postList.HasPrevious, postList.HasNext); var result = new { values = shapdeWithLinks, links }; var meta = new { postList.PageSize, postList.PageIndex, postList.TotalItemsCount, postList.PageCount, }; Response.Headers.Add(\u0026#34;X-Pagination\u0026#34;, JsonConvert.SerializeObject(meta, new JsonSerializerSettings { //使得命名符合驼峰命名法  ContractResolver = new CamelCasePropertyNamesContractResolver() })); return Ok(result); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  [HttpGet(Name = \u0026#34;GetPosts\u0026#34;)] [RequestHeaderMatchingMediaType(\u0026#34;Accept\u0026#34;, new[] { \u0026#34;application/json\u0026#34; })] //不是自定义的mediaType按json返回，元数据包含在返回的head中  public async Task\u0026lt;IActionResult\u0026gt; Get(PostParameters postParameters) { if (!_propertyMappingContainer.ValidateMappingExistsFor\u0026lt;PostResource, Post\u0026gt;(postParameters.OrderBy)) { return BadRequest(\u0026#34;cannot finds fields for sorting.\u0026#34;); } if (!_typeHelperService.TypeHasProperties\u0026lt;PostResource\u0026gt;(postParameters.Fields)) { return BadRequest(\u0026#34;Fields not exist.\u0026#34;); } var postList = await _postRepository.GetAllPostsAsync(postParameters); var postResources = _mapper.Map\u0026lt;IEnumerable\u0026lt;Post\u0026gt;, IEnumerable\u0026lt;PostResource\u0026gt;\u0026gt;(postList); var previousPageLink = postList.HasPrevious ? CreatePostUri(postParameters, PaginationResourceUriType.PreviousPage) : null; var nextPageLink = postList.HasNext ? CreatePostUri(postParameters, PaginationResourceUriType.NextPage) : null; var meta = new { postList.PageSize, postList.PageIndex, postList.TotalItemsCount, postList.PageCount, previousPageLink, nextPageLink }; Response.Headers.Add(\u0026#34;X-Pagination\u0026#34;, JsonConvert.SerializeObject(meta, new JsonSerializerSettings { //使得命名符合驼峰命名法  ContractResolver = new CamelCasePropertyNamesContractResolver() })); return Ok(postResources.ToDynamicIEnumerable(postParameters.Fields)); }   ","description":"","id":26,"section":"code","tags":null,"title":"11_HATEOAS","uri":"https://xtddw.github.io/code/dotnetcore/11hateoas/"},{"content":"安全性\u0026amp;幂等性  安全性☞方法执行后并不会改变资源的表述 幂等性☞方法无论执行多少次都会得到同样的结果\n  POST 添加资源 不安全，不幂等\n 参数[FromBody] 返回201 Created\n* CreatedAtRoute(): 它允许响应里带着LocationHeader，其中包含着一个URI,通过这个URI就可以GET到我们刚刚创建好的资源。 HATEOAS   PostAddResource  1 2 3 4 5  public class PostAddResource { public string Title { get; set; } public string Body { get; set; } }   MappingProfile  1 2 3 4 5 6 7 8 9  public MappingProfile() { CreateMap\u0026lt;Post, PostResource\u0026gt;() .ForMember(dest =\u0026gt; dest.UpdateTime, opt =\u0026gt; opt.MapFrom(src =\u0026gt; src.LastModified)); CreateMap\u0026lt;PostResource, Post\u0026gt;(); CreateMap\u0026lt;PostAddResource,Post\u0026gt;(); }   Action中Post方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  [HttpPost(Name =\u0026#34;CreatePost\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; Post([FromBody] PostAddResource postAddResource) { if (postAddResource == null) { return BadRequest(\u0026#34;not data!\u0026#34;); } var newPost = _mapper.Map\u0026lt;PostAddResource, Post\u0026gt;(postAddResource); newPost.Author = \u0026#34;admin\u0026#34;; newPost.LastModified = DateTime.Now; _postRepository.AddPost(newPost); if (!await _unitOfWork.SaveAsync()) { throw new Exception(\u0026#34;Save post data Failed!\u0026#34;); } var resultResource = _mapper.Map\u0026lt;Post, PostResource\u0026gt;(newPost); //HATEOAS  var links = CreateLinksForPost(newPost.Id); var linkedPostResource = resultResource.ToDynamic() as IDictionary\u0026lt;string, object\u0026gt;; linkedPostResource.Add(\u0026#34;links\u0026#34;, links); //return Ok(resultResource);//200  return CreatedAtRoute(\u0026#34;GetPost\u0026#34;,new { id = linkedPostResource[\u0026#34;Id\u0026#34;] },linkedPostResource); //201  }   Model 验证  定义验证规则 检查验证规则 把验证错误信息发送给API消费者   内置验证：  DataAnnotation\n ValidationAttribute IValidatebleObject   第三方FluentValidation  关注点分离（SOC,Seperation of Concerns) 安装包\n* FluentValidation\n* FluentValidation.AspNetCore 为每一个Resource建立验证器  继承AbstractValidator\n      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public class PostAddResourceValidator:AbstractValidator\u0026lt;PostAddResource\u0026gt; { public PostAddResourceValidator() { RuleFor(x =\u0026gt; x.Title) .NotNull() .WithName(\u0026#34;标题\u0026#34;) .WithMessage(\u0026#34;{PropertyName}是必填的\u0026#34;) .MaximumLength(50) .WithMessage(\u0026#34;{PropertyName}的最大长度是{MaxLength}\u0026#34;); RuleFor(x =\u0026gt; x.Body) .NotNull() .WithName(\u0026#34;正文\u0026#34;) .WithMessage(\u0026#34;{PropertyName}是必填的\u0026#34;) .MinimumLength(50) .WithMessage(\u0026#34;{PropertyName}的最小长度是{MaxLength}\u0026#34;); } }    配置  1 2  //注册FluentValidator services.AddTransient\u0026lt;IValidator\u0026lt;PostAddResource\u0026gt;, PostAddResourceValidator\u0026gt;();   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  services.AddMvc( options =\u0026gt; { options.ReturnHttpNotAcceptable = true; //开启406  //options.OutputFormatters.Add(new XmlDataContractSerializerOutputFormatter());  //自定义mediaType  var outputFormatter = options.OutputFormatters.OfType\u0026lt;JsonOutputFormatter\u0026gt;().FirstOrDefault(); if (outputFormatter != null) { outputFormatter.SupportedMediaTypes.Add(\u0026#34;application/vnd.enfi.hateoas+json\u0026#34;); } }) .AddJsonOptions(options =\u0026gt; { options.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver(); }) .AddFluentValidation();    验证  ModelStatus.IsValid ModelState  字典，包含Model的状态以及Model所绑定的验证 对于提交的每个属性，它都包含了一个错误信息的集合     返回：422 UnprocessableEntity  验证错误信息在响应的body里面带回去    1 2 3 4  if (!ModelState.IsValid) { return UnprocessableEntity(ModelState); }    MediaType  1 2 3 4 5  var inputFormatter = options.InputFormatters.OfType\u0026lt;JsonInputFormatter\u0026gt;().FirstOrDefault(); if (inputFormatter!=null) { inputFormatter.SupportedMediaTypes.Add(\u0026#34;application/vnd.enfi.post.create+json\u0026#34;); }   1 2 3 4 5 6 7  [HttpPost(Name =\u0026#34;CreatePost\u0026#34;)] [RequestHeaderMatchingMediaType(\u0026#34;Content-Type\u0026#34;, new[] { \u0026#34;application/vnd.enfi.post.create+json\u0026#34; })] [RequestHeaderMatchingMediaType(\u0026#34;Accept\u0026#34;, new[] { \u0026#34;application/vnd.enfi.hateoas+json\u0026#34; })] public async Task\u0026lt;IActionResult\u0026gt; Post([FromBody] PostAddResource postAddResource) { ... }   POST 一次性添加集合资源  把整个集合看作一种资源 参数[FromBody]IEnumerable 返回201，CreatedAtRoute()，带着ID的集合 GET方法参数为ID的集合，用于查询创建的集合资源  ArrayModelBinder:IModelBinder    自定义验证错误返回结果  满足Angular客户端表单验证要求：  错误的类型：required,maxLength \u0026hellip;   MyUnprocessableEntityObjectResult  继承：ObjectResult ResourceValidationResult:Dictionary\u0026lt;string,IEnumerable\u0026gt;     PostAddResourceValidator  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public class PostAddResourceValidator:AbstractValidator\u0026lt;PostAddResource\u0026gt; { public PostAddOrUpdateResourceValidator() { RuleFor(x =\u0026gt; x.Title) .NotNull() .WithName(\u0026#34;标题\u0026#34;) .WithMessage(\u0026#34;required|{propertyName}是必填的\u0026#34;) .MaximumLength(50) .WithMessage(\u0026#34;maxlength|{PropertyName}的最大长度是{MaxLength}\u0026#34;); RuleFor(x =\u0026gt; x.Body) .NotNull() .WithName(\u0026#34;正文\u0026#34;) .WithMessage(\u0026#34;required|{PropertyName}是必填的\u0026#34;) .MinimumLength(50) .WithMessage(\u0026#34;minlength|{PropertyName}的最小长度是{MinLength}\u0026#34;); } }   ResourceValidationError  1 2 3 4 5 6 7 8 9 10 11 12  public class ResourceValidationError { public ResourceValidationError(string message,string validatorKey =\u0026#34;\u0026#34;) { Message = message; ValidatorKey = validatorKey; } public string Message { get; private set; } public string ValidatorKey { get; private set; } }   ResourceValidationResult  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public class ResourceValidationResult:Dictionary\u0026lt;string,IEnumerable\u0026lt;ResourceValidationError\u0026gt;\u0026gt; { public ResourceValidationResult():base(StringComparer.OrdinalIgnoreCase) { } public ResourceValidationResult(ModelStateDictionary modelState):this() { if (modelState ==null) { throw new ArgumentNullException(nameof(modelState)); } foreach (var keyModelStatePair in modelState) { var key = keyModelStatePair.Key; var errors = keyModelStatePair.Value.Errors; if (errors!=null\u0026amp;\u0026amp;errors.Count\u0026gt;0) { var errorsToAdd = new List\u0026lt;ResourceValidationError\u0026gt;(); foreach (var error in errors) { var keyAndMessage = error.ErrorMessage.Split(\u0026#39;|\u0026#39;); if (keyAndMessage.Length \u0026gt;1) { errorsToAdd.Add(new ResourceValidationError(keyAndMessage[1], keyAndMessage[0])); } else { errorsToAdd.Add(new ResourceValidationError(keyAndMessage[0])); } } Add(key, errorsToAdd); } } } }   MyUnprocessableEntityObjectResult  1 2 3 4 5 6 7 8 9 10 11  public class MyUnprocessableEntityObjectResult : UnprocessableEntityObjectResult { public MyUnprocessableEntityObjectResult(ModelStateDictionary modelState) : base(new ResourceValidationResult(modelState)) { if (modelState == null) { throw new ArgumentNullException(nameof(modelState)); } StatusCode = 422; } }   使用  1 2 3 4 5  if (!ModelState.IsValid) { return new MyUnprocessableEntityObjectResult(ModelState); //return UnprocessableEntity(ModelState); }   DELETE  参数： ID 返回： 204 No Content 不安全 幂等：多次请求的副作用和单次请求的副作用是一样的，每次发送DELETE请求后，服务器的状态是一样的  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  [HttpDelete(\u0026#34;{id}\u0026#34;,Name =\u0026#34;DeletePost\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; DeletePost(int id) { var post = await _postRepository.GetPostByIdAsync(id); if (post ==null) { return NotFound(); } _postRepository.DeletePost(post); if (!await _unitOfWork.SaveAsync()) { throw new Exception($\u0026#34;Deleting post {id} failed when saving.\u0026#34;); } return NoContent(); }   PUT 整体更新  参数： ID [FromBody]不需要ID属性  单独的Resource Model.   返回： 204 No Content 202 OK 不安全 幂等 整体更新 容易引起问题 集合资源整体更新   抽象父类  1 2 3 4 5  public class PostAddOrUpdateResource { public string Title { get; set; } public string Body { get; set; } }   继承  1 2 3  public class PostUpdateResource:PostAddOrUpdateResource { }   修改FluentValidator  1 2 3 4  public class PostAddOrUpdateResourceValidator\u0026lt;T\u0026gt;:AbstractValidator\u0026lt;T\u0026gt; where T:PostAddOrUpdateResource { ...... }   修改注册  1 2 3  //注册FluentValidator  services.AddTransient\u0026lt;IValidator\u0026lt;PostAddResource\u0026gt;, PostAddOrUpdateResourceValidator\u0026lt;PostAddResource\u0026gt;\u0026gt;(); services.AddTransient\u0026lt;IValidator\u0026lt;PostUpdateResource\u0026gt;, PostAddOrUpdateResourceValidator\u0026lt;PostUpdateResource\u0026gt;\u0026gt;();   添加mappingProfile  1  CreateMap\u0026lt;PostUpdateResource,Post\u0026gt;();   6.Action\u0026raquo;\u0026gt;Post\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  [HttpPut(\u0026#34;{id}\u0026#34;,Name =\u0026#34;UpdatePost\u0026#34;)] //注意要在mvc中注册 Content-Type [RequestHeaderMatchingMediaType(\u0026#34;Content-Type\u0026#34;, new[] { \u0026#34;application/vnd.enfi.post.update+json\u0026#34; })] public async Task\u0026lt;IActionResult\u0026gt; UpdatePost(int id,[FromBody] PostUpdateResource postUpdate) { if (postUpdate == null) { return BadRequest(); } if (!ModelState.IsValid) { return new MyUnprocessableEntityObjectResult(ModelState); } var post = await _postRepository.GetPostByIdAsync(id); if (post == null) { return NotFound(\u0026#34;Cannot found the data for update.\u0026#34;); } post.LastModified = DateTime.Now; _mapper.Map(postUpdate, post); if (!await _unitOfWork.SaveAsync()) { throw new Exception($\u0026#34;Deleting post {id} failed when updating.\u0026#34;); } return NoContent(); }   PATCH 局部更新  application/json-patch+json\n 参数： ID [FromBody] JsonPatchDocument patchDoc.ApplyTo() 返回： 204 No Content 202 OK 不安全 不幂等   Repository中添加Update方法  1 2 3 4  public void UpdatePost(Post post) { _applicationContext.Entry(post).State = EntityState.Modified; }   Action 中添加Update方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  [HttpPatch(\u0026#34;{id}\u0026#34;,Name =\u0026#34;PartiallyUpdatePost\u0026#34;)] public async Task\u0026lt;IActionResult\u0026gt; PartiallyUpdatePost(int id,[FromBody] JsonPatchDocument\u0026lt;PostUpdateResource\u0026gt; pathDoc) { if (pathDoc ==null) { return BadRequest(); } var post = await _postRepository.GetPostByIdAsync(id); if (post ==null) { return NotFound(\u0026#34;Cannot found the data for update.\u0026#34;); } var postToPatch = _mapper.Map\u0026lt;PostUpdateResource\u0026gt;(post); pathDoc.ApplyTo(postToPatch, ModelState); TryValidateModel(postToPatch); if (!ModelState.IsValid) { return new MyUnprocessableEntityObjectResult(ModelState); } _mapper.Map(postToPatch, post); post.LastModified = DateTime.Now; _postRepository.UpdatePost(post); if (!await _unitOfWork.SaveAsync()) { throw new Exception($\u0026#34;post {id} failed when partially updating patch.\u0026#34;); } return NoContent(); }   总结 ","description":"","id":27,"section":"code","tags":null,"title":"12_CURD","uri":"https://xtddw.github.io/code/dotnetcore/12postputpatchdelete/"},{"content":"BASE ","description":"","id":28,"section":"code","tags":null,"title":"base go","uri":"https://xtddw.github.io/code/go/base/"},{"content":"准备  https://identityserver4.readthedocs.io/en/release/ OpenID Connect \u0026amp; OAuth 2.0 framework for ASP.NET Core 2.   建立Identity Provider项目   IdentityServer4.Templates https://github.com/IdentityServer/IdentityServer4.Templates 安装工具:  dotnet new -i identityserver4.templates 重置 “dotnet new” 功能列表: dotnet new --debug:reinit   模板:  dotnet new is4empty dotnet new is4ui dotnet new is4inmem dotnet new is4aspid dotnet new is4ef dotnet new is4admin (收费)    创建项目  dotnet new -i identityserver4.templates dotnet new is4aspid --name BlogIdp 升级为.NET Core 2.1, 更新Nuget包 配置Hsts|HttpsRedirection  1 2 3 4 5 6 7 8 9 10 11 12 13 14  //注册Hsts  services.AddHsts(options =\u0026gt; { options.Preload = true; options.IncludeSubDomains = true; options.MaxAge = TimeSpan.FromDays(60); }); //配置HTTP重定向  services.AddHttpsRedirection(options =\u0026gt; { options.RedirectStatusCode = StatusCodes.Status307TemporaryRedirect; options.HttpsPort = 6001; });   MVC 测试  安全/机密客户端(Confidential Client), 它是传统的服务器端Web应用. 它需要长时间访问(long-lived access), 所以需要refresh token. 那么它可以使用Authorization Code Flow或Hybrid Flow. Hybrid Flow是相对高级一些的, 它可以让客户端首先从授权端点获得一个ID Token并通过浏览器(front-channel)传递过来, 这样我们就可以验证这个ID Token. 如果验证成功然后, 客户端再打开一个后端通道(back-channel), 从Token端点获取Access Token.   身份认证请求\n   第一行的URI: \u0026ldquo;/authorize\u0026rdquo; 就是授权端点(Authorization Endpoint), 它位于身份提供商(Identity provider, IDP)那里. 这个URI可以从前面介绍的discovery document里面找到. 第二行 response_type=code id_token, 它决定了采取了哪一种Hybrid流程(参考上面那三个图). 第三行 client_id=xxxx, 这是客户端的身份标识. 第四行 redirect_uri=https\u0026hellip;., 这是客户端那里的重定向端点(Redirection Endpoint). 第五行 scope=openid profile email, 这就是客户端所请求的scopes.  Hybrid Flow\n   为什么要返回两次ID Token呢? 这是因为第(4)步里面请求Token的时候要求客户端身份认证, 这时请求Token的时候需要提供Authorization Code, Client ID和 Client Secret, 这些secret并不暴露给外界, 这些东西是由客户端服务器通过后端通道传递给Token端点的. 而第一次获得的ID Token是从前端通道(浏览器)返回的. 当这个ID Token被验证通过之后, 也就证明了当前用户到底是谁.\n  code demo  新建MVC 修改端口为7000，7001 修改Idp项目config.cs  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  new Client { ClientId = \u0026#34;mvcclient\u0026#34;, ClientName = \u0026#34;MVC客户端\u0026#34;, AllowedGrantTypes = GrantTypes.HybridAndClientCredentials, ClientSecrets = { new Secret(\u0026#34;49C1A7E1-0C79-4A89-A3D6-A37998FB86B0\u0026#34;.Sha256()) }, RedirectUris = { \u0026#34;http://localhost:7001/signin-oidc\u0026#34; }, FrontChannelLogoutUri = \u0026#34;http://localhost:7001/signout-oidc\u0026#34;, PostLogoutRedirectUris = { \u0026#34;http://localhost:7001/signout-callback-oidc\u0026#34; }, AllowOfflineAccess = true, //offline_access(refresh token)  AllowedScopes = { IdentityServerConstants.StandardScopes.OpenId }// { \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34;, \u0026#34;api1\u0026#34; }  },   修改mvc项目Startup  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } public void ConfigureServices(IServiceCollection services) { services.Configure\u0026lt;CookiePolicyOptions\u0026gt;(options =\u0026gt; { // This lambda determines whether user consent for non-essential cookies is needed for a given request.  options.CheckConsentNeeded = context =\u0026gt; true; options.MinimumSameSitePolicy = SameSiteMode.None; }); services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1); JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear(); services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = \u0026#34;Cookies\u0026#34;; options.DefaultChallengeScheme = \u0026#34;oidc\u0026#34;; }) .AddCookie(\u0026#34;Cookies\u0026#34;, options =\u0026gt; { options.AccessDeniedPath = \u0026#34;/Authorization/AccessDenied\u0026#34;; }) .AddOpenIdConnect(\u0026#34;oidc\u0026#34;, options =\u0026gt; { options.SignInScheme = \u0026#34;Cookies\u0026#34;; options.Authority = \u0026#34;https://localhost:6001\u0026#34;; options.RequireHttpsMetadata = true; options.ClientId = \u0026#34;mvcclient\u0026#34;; options.ResponseType = \u0026#34;code id_token\u0026#34;; options.Scope.Clear(); options.Scope.Add(\u0026#34;openid\u0026#34;); //与Idp中config对应  //options.Scope.Add(\u0026#34;profile\u0026#34;);  //options.Scope.Add(\u0026#34;email\u0026#34;);  //options.Scope.Add(\u0026#34;restapi\u0026#34;);  options.SaveTokens = true; options.ClientSecret = \u0026#34;49C1A7E1-0C79-4A89-A3D6-A37998FB86B0\u0026#34;; options.GetClaimsFromUserInfoEndpoint = true; }); } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } else { app.UseExceptionHandler(\u0026#34;/Home/Error\u0026#34;); app.UseHsts(); } app.UseHttpsRedirection(); app.UseAuthentication(); app.UseStaticFiles(); app.UseCookiePolicy(); app.UseMvc(routes =\u0026gt; { routes.MapRoute( name: \u0026#34;default\u0026#34;, template: \u0026#34;{controller=Home}/{action=Index}/{id?}\u0026#34;); }); } }   HomeController 测试  1 2 3 4 5 6 7 8  [Authorize] public class HomeController : Controller { public IActionResult Index() { return View(); } ......   6. 添加更多获取资源\n1 2 3 4 5 6 7 8  public async Task\u0026lt;IActionResult\u0026gt; About() { var idToken = await HttpContext.GetTokenAsync(OpenIdConnectParameterNames.IdToken); ViewData[\u0026#34;idToken\u0026#34;] = idToken; return View(); }   Config.cs添加  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public static IEnumerable\u0026lt;IdentityResource\u0026gt; GetIdentityResources() { return new IdentityResource[] { new IdentityResources.OpenId(), new IdentityResources.Profile(), new IdentityResources.Email(), }; } public static IEnumerable\u0026lt;ApiResource\u0026gt; GetApis() { return new ApiResource[] { new ApiResource(\u0026#34;restapi\u0026#34;, \u0026#34;My RESTful API\u0026#34;) }; }   1 2 3 4 5 6 7 8  AllowOfflineAccess = true, //offline_access(开启refresh token)  AllowedScopes = { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, IdentityServerConstants.StandardScopes.Email, \u0026#34;restapi\u0026#34; }// { \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34;, \u0026#34;api1\u0026#34; }   修改html  1 2 3 4 5 6 7 8 9 10 11 12 13  @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;About\u0026#34;; } \u0026lt;h2\u0026gt;@ViewData[\u0026#34;Title\u0026#34;]\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;IdToken:@ViewData[\u0026#34;idToken\u0026#34;]\u0026lt;/h3\u0026gt; \u0026lt;dl\u0026gt; @foreach (var claim in User.Claims) { \u0026lt;dt\u0026gt;@claim.Type\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;@claim.Value\u0026lt;/dd\u0026gt; } \u0026lt;/dl\u0026gt;   保护API资源  安装包 `IdentityServer4.AccessTokenValidation 注册  1 2 3 4 5 6 7 8  // 注册IdentityServer  services.AddAuthentication(IdentityServerAuthenticationDefaults.AuthenticationScheme) .AddIdentityServerAuthentication(options =\u0026gt; { options.Authority = \u0026#34;https://localhost:6001\u0026#34;; options.ApiName = \u0026#34;restapi\u0026#34;; });   config\napp.UseAuthentication(); api中加验证  属性标签 [Authorize] 全局filter    1 2 3 4 5 6 7 8  //设置全局filter保护api需要认真用户才可访问  services.Configure\u0026lt;MvcOptions\u0026gt;(options =\u0026gt; { var policy = new AuthorizationPolicyBuilder() .RequireAuthenticatedUser() .Build(); options.Filters.Add(new AuthorizeFilter(policy)); });   NoAuth\n MVC客户端   安装IdentityModel 修改HomeController  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public async Task\u0026lt;IActionResult\u0026gt; Contact() { var httpClient = new HttpClient { BaseAddress = new Uri(\u0026#34;https://localhost:5001\u0026#34;) }; httpClient.DefaultRequestHeaders.Clear(); httpClient.DefaultRequestHeaders.Accept.Add( new MediaTypeWithQualityHeaderValue(\u0026#34;application/vnd.enfi.hateoas+json\u0026#34;) ); var accessToken = await HttpContext.GetTokenAsync(OpenIdConnectParameterNames.AccessToken); ViewData[\u0026#34;accessToken\u0026#34;] = accessToken; httpClient.SetBearerToken(accessToken); var res = await httpClient.GetAsync(\u0026#34;api/posts\u0026#34;).ConfigureAwait(false); if (res.IsSuccessStatusCode) { var json = await res.Content.ReadAsStringAsync().ConfigureAwait(false); var objects = JsonConvert.DeserializeObject\u0026lt;dynamic\u0026gt;(json); ViewData[\u0026#34;json\u0026#34;] = objects; return View(); } if (res.StatusCode == HttpStatusCode.Unauthorized) { return RedirectToAction(\u0026#34;AccessDenied\u0026#34;, \u0026#34;Authorization\u0026#34;); } throw new Exception($\u0026#34;Error Occurred:${res.ReasonPhrase}\u0026#34;); }    添加 Authorization/AccessDenied  1 2 3 4 5 6 7  public class AuthorizationController : Controller { public IActionResult AccessDenied() { return View(); } }   1 2 3 4  @{ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;AccessDenied\u0026#34;;} \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Access Denied\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt;   https://jwt.io 网站解析token  ","description":"","id":29,"section":"code","tags":null,"title":"ex_IdentityServer4","uri":"https://xtddw.github.io/code/dotnetcore/identityserver4/"},{"content":"OAuth 2.0 vs OpenId Connect OAuth 2.0  OAuth 2.0是一个委托协议, 它可以让那些控制资源的人允许某个应用代表他们来访问他们控制的资源, 注意是代表这些人, 而不是假冒或模仿这些人. 这个应用从资源的所有者那里获得到授权(Authorization)和access token, 随后就可以使用这个access token来访问资源. (这里提到的假冒或模仿就是指在客户端复制一份用户名和密码，从而获取相应的权限)。 是关于授权(Authorization)的, 客户端应用可以请求access token, 使用这个token就可以访问API资源了 让客户端应用可以代表资源所有者(通常是用户)来访问被保护的资源\n 资源所有者(Resource Owner), 他拥有访问API资源的权限, 并且他还可以委派权限(delegate)给其他应用来访问API. 资源所有者通常是可以使用浏览器的人. 被保护的资源(Protected Resource)就是资源所有者拥有权限去访问的组件, 它可以是很多种形式的, 但是web API的形式还是最常见的. 客户端(Client)应用就是代表资源所有者访问被保护资源的一个软件. 注意它既不是指浏览器, 也不是指给你钱让你开发软件的人. 在OAuth2里面, 它是指被保护的API资源的消费者.     授权服务器 (Authorization Server, AS)   是被受保护的资源所信任的, 它可以发行具有特定目的的安全凭据给客户端应用, 这个凭据叫做OAuth的 access token.\n  授权种类   Authorization Code mplicit Resource Owner Password Credentials, 直接使用密码凭据(用户名和密码)作为授权来获得access token. 只有当资源所有者和客户端之间高度信任的时候并且其它授权方式不可用的时候才可以使用这种授权方式 Client Credentials, 有时候, 资源或者叫资源服务器并不属于某个最终用户, 也就是没有资源所有者对该资源负责. 但是客户端应用肯定还是要访问这些资源, 这时候就只能使用Client Credentials这种授权方式了.  其它重要角色和组件   资源所有者 Resource Owner 客户端 Client 被保护资源 Protected Resource 授权服务器 Authorization Server Access Token, 它是用来访问被保护资源的凭据. 授权服务器只是发行token, 被保护资源验证token. 客户端对于access token应该是完全健忘的. Scopes, 表示被保护资源那里的一套权限, 具有叠加性. Refresh Token, 用来获得Access Token的凭据. 客户端是用refresh token来请求新的access token  通过refresh token来取得新的access token的流程\n 重要端点   授权端点(authorization endpoint)是用来和资源所有者交互的, 资源所有者在这里进行登录(身份认证), 然后通过该端点可以对客户端进行授权(authorization grant). 授权服务器首先要验证资源所有者的身份, 但是验证的方式并不在OAuth2的协议范围内. Token端点(token endpoint), 客户端通过向token端点展示它的授权(auhtorization grant)或refresh token来获取access token. 除了implicit之外所有的授权类型都需要使用该端点, 因为implicit的access token是直接发行的.  OpenId Connect   身份认证与授权\n OAuth 2.0 不是身份认证(Authentication)协议, OpenId Connect 可以进行身份认证(Authentication).\n一个比喻:\n授权: 生牛奶 (多用途原料).\n身份认证: 奶茶 (一个最终产品), 以牛奶为主原料. OAuth 2.0, 生牛奶, 众多web安全架构的一种多用途的基本成分. OIDC, 奶茶, 基于OAuth 2.0的身份认证协议, 添加了一些组件来提供身份认证的能力.    更高级的协议, 扩展并替代了OAuth2\n OpenID Connect是建立在OAuth2协议上的一个简单的身份标识层, 所以OpenID Connect兼容OAuth2.  使用OpenID Connect, 客户端应用可以请求identity token, 它会和access token一同返回给客户端应用. 这个identity token就可以被用来登录客户端应用程序, 而客户端应用还可以使用access token来访问API资源. UserInfo端点, (OAuth2定义了Authorization端点和Token端点)它允许客户端应用获取用户的额外信息.  定义了不同类型的应用如何从身份识别提供商(IDP)安全的获取这些token    与OAuth 2.0之间的角色映射关系\n身份提供商(Identity Provider, IdP)\n依赖方(Relying Party, RP, 可以理解为客户端)\n OAuth2里可以分为两部分: 1.资源所有者/客户端应用, 2.授权服务器/被保护资源. 身份认证协议里也是两大部分: 1.依赖方, 2.身份提供商. 映射OAuth 2 \u0026mdash;- OIDC  授权服务器/被保护资源 \u0026mdash;- 身份提供商进行映射 资源所有者 \u0026mdash;- 最终用户 客户端应用 \u0026mdash;- 依赖方(RP).\n      抽象流程\n 依赖发(RP)发送请求到OpenID提供商(OP, 也就是身份提供商). OpenID提供商验证最终用户的身份, 并获得了用户委派的授权 OpenID提供商返回响应, 里面带着ID Token, 也通常带着Access Token. 依赖方现在可以使用Access Token发送请求到用户信息的端点. 用户信息端点返回用户的声明(claims, 相当于是用户的信息).\n    身份认证流程  Authorization Code Flow  在Authorization Code 流程里, 一个授权码(Authorization Code)会被返回给客户端. 这个授权码可以被直接用来交换ID Token和Access Token. 该流程也可以在客户端使用授权码兑换Access Token之前对其身份认证. 但是该流程要求客户端的身份认证动作在后台使用client id和secret来获得tokens, 这样就不会把tokens暴露给浏览器或其它可访问浏览器的恶意应用了. 要求客户端应用可以安全的在它和授权服务器之间维护客户端的secret, 也就是说只适合这样的客户端应用. 它还适合于长时间的访问(通过refresh token). 授权码来自于授权端点, 而所有的tokens都来自于Token端点.  Authorization Code流程的步骤如下:  客户端准备身份认证请求, 请求里包含所需的参数 客户端发送请求到授权服务器 授权服务器对最终用户进行身份认证 授权服务器获得最终用户的同意/授权 授权服务器把最终用户发送回客户端, 同时带着授权码 客户端使用授权码向Token端点请求一个响应 客户端接收到响应, 响应的body里面包含着ID Token 和 Access Token 客户端验证ID Token, 并获得用户的一些身份信息.     Implicit Flow(Angular)  Implicit Flow在请求token的时候不需要明确的客户端身份认证, 它使用重定向URI的方式来验证客户端的身份. 因为这一点, refresh token也就无法使用了, 这同样也不适合于长时间有效的access token. 所有的tokens都来自于授权端点, 而Token端点并没有用到. 该流程主要用于浏览器内的应用, Access Token和ID Token一同被直接返回给客户端. 因为这个原因, 这些tokens也会暴露于最终用户和可以访问该浏览器的其它应用了.  它并不适合于长时间的访问. Implicit流程的步骤如下:  客户端准备身份认证请求, 请求里包含所需的参数 客户端发送请求到授权服务器 授权服务器对最终用户进行身份认证 授权服务器获得最终用户的同意/授权 授权服务器把最终用户发送回客户端, 同时带着ID Token. 如果也请求了Access Token的话, 那么Access Token也会一同返回. 客户端验证ID Token, 并获得用户的一些身份信息.     Hybrid Flow  Hybrid Flow是前两者的混合, 在该流程里. 有一些tokens和授权码来自于授权端点, 而另外一些tokens则来自于Token端点. 该流程允许客户端立即使用ID Token, 并且只需要一次往返即可获得授权码. 这种流程也要求客户端应用可以安全的维护secret. 它也适合于长时间的访问.\nHybrid流程的步骤如下:  客户端准备身份认证请求, 请求里包含所需的参数 客户端发送请求到授权服务器 授权服务器对最终用户进行身份认证 授权服务器获得最终用户的同意/授权 授权服务器把最终用户发送回客户端, 同时带着授权码, 根据响应类型的不同, 也可能还带着一个或者多个其它的参数. 客户端使用授权码向Token端点请求一个响应 客户端接收到响应, 响应的body里面包含着ID Token 和 Access Token 客户端验证ID Token, 并获得用户的一些身份信息.     比较\n  Hybrid Flow 根据response_type的不同, 分为:\n response_type=code id_token response_type=code token response_type=code id_token token\n注意:为了表明是OpenID Connect协议的请求, scope参数里必须包含openid   response_type=code id_token\n response_type=code token\n response_type=code id_token token\n  ","description":"","id":30,"section":"code","tags":null,"title":"ex_OAuth2","uri":"https://xtddw.github.io/code/dotnetcore/oauth2openidconnect/"},{"content":"flask部署 不建议在windows系统上部署flask应用\n准备  IP config MongoDB setup MongoDB-express setup Nginx  linux 系统 * uwsgi  windows系统 * waitress * 编写.bat文件 RunHiddenConsole * 把.bat快捷方式发送开机启动目录  响应 flask默认支持2种响应方式：\n 数据响应：默认响应html文本，也可以返回JSON格式(jsonify()函数) 页面响应：  重定向 redirect('\u0026ldquo;http://www.baidu.com\u0026quot;') || redirect('/json\u0026rsquo;) redirect(url_for(\u0026ldquo;视图函数名\u0026rdquo;)）自动解析对应视图函数名称的url地址    响应时，flask也支持自定义http响应状态码\n","description":"","id":31,"section":"code","tags":null,"title":"Flask","uri":"https://xtddw.github.io/code/python/flask/"},{"content":"jupyter  jupyter 0198  1 2 3 4 5 6  @echo off cd \u0026#34;c:\\jupyter\u0026#34;\rjupyter notebook\recho 【按任意键退出】\rpause\u0026gt;nul\rexit\r  mysql  3306 root 12346  1 2 3 4 5 6  @echo off cd \u0026#34;C:\\MySQL\\Engine\\bin\u0026#34;\rmysqld --console\recho 【按任意键退出】\rpause\u0026gt;nul\rexit\r  mkdocs 1  mkdocs serve --dev-addr=0.0.0.0:5858\r  zhtj  ID ggcjdss9/  server  10.30.0.14 enfiyjy-svr\\svradmin ggcjdss9/  ","description":"","id":32,"section":"note","tags":null,"title":"sercet","uri":"https://xtddw.github.io/note/sercet/"},{"content":"whoami  Name: 张官祥 Phone: +8613811772347 Email: zhanggx@enfi.com.cn Blog: xtddw Company: 中国恩菲工程技术有限公司  ","description":"","id":33,"section":"","tags":null,"title":"","uri":"https://xtddw.github.io/about/"},{"content":"万 王 张 宋\n行业解决方案\n数据驱动\n中石化 PaaS服务\n云平台租赁 SaaS服务\n私有云与公有云的版本维护、安全管理\n统一设备接入标准（Roma平台产品)\n设计院的数字化交付（产权、使用权限等）\n供应链协同\n数字化集成平台\n全连接工鞋协同数字化座舱 WeLink\n华为去A\n智慧园区\nAtlas人工智能训练算法，嵌入设备\n合作分工：华为云端资源提供，边缘计算服务\n","description":"","id":34,"section":"work","tags":null,"title":"","uri":"https://xtddw.github.io/work/huawei/"}]